This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-22T18:50:05.098Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
app/
  admin/
    page.tsx
  api/
    auth/
      [kindeAuth]/
        route.ts
    cron/
      monthly-token-distribution/
        route.ts
    dalle/
      route.ts
    dreamy/
      route.ts
    payment-success/
      route.ts
    payment-success-1000/
      route.ts
    payment-success-1500/
      route.ts
    payment-success-500/
      route.ts
    process-query/
      route.ts
    test/
      route.ts
  chat/
    page.module.css
    page.tsx
  payment-complete/
    page.tsx
  globals.css
  layout.tsx
  page.module.css
  page.tsx
components/
  auth/
    authForm.tsx
  chat/
    ChatComponent.tsx
    page.module.css
  disclaimer/
    disclaimermodal.module.css
    dislaimer.tsx
  StatsCard/
    StatsCard.tsx
  token system/
    TokenSystem.ts
  utils/
    tokenUtils/
      TokenUtility.ts
      types.ts
  dreamhistorymenu.tsx
constants/
  constants.ts
supabase/
  supabaseClient.js
.gitignore
middelware.ts
next.config.mjs
package.json
postcss.config.cjs
README.md
tsconfig.json
vercel.json

================================================================
Repository Files
================================================================

================
File: app/admin/page.tsx
================
'use client'

import React, { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  AppShell,
  AppShellHeader,
  AppShellNavbar,
  AppShellMain,
  Title,
  LoadingOverlay,
  Container,
  Button,
  Stack,
  Group,
  Notification,
} from '@mantine/core';
import { IconCheck } from '@tabler/icons-react';
import { createClient } from '@supabase/supabase-js';
import StatsCard from '@/components/StatsCard/StatsCard';

const AdminSettings = () => {
  const [isAdmin, setIsAdmin] = useState<boolean | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [successMessage, setSuccessMessage] = useState('');
  const [stats, setStats] = useState({
    totalUsers: 0,
    totalSubscribers: 0,
    totalSessions: 0,
    totalTokensSpent: 0,
  });
  const router = useRouter();
  
  const supabase = createClient(
    process.env.SUPABASE_URL!,
    process.env.SUPABASE_KEY!
  );

  useEffect(() => {
    const checkAdminStatus = async () => {
      try {
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        
        if (userError || !user) {
          setIsAdmin(false);
          return;
        }

        const { data, error } = await supabase
          .from('users')
          .select('is_admin')
          .eq('id', user.id)
          .single();

        if (error || !data) {
          console.error('Error fetching admin status:', error);
          setIsAdmin(false);
        } else {
          setIsAdmin(data.is_admin);
        }
      } catch (error) {
        console.error('Error checking admin status:', error);
        setIsAdmin(false);
      } finally {
        setIsLoading(false);
      }
    };

    checkAdminStatus();
  }, [supabase]);

  useEffect(() => {
    if (!isLoading && !isAdmin) {
      router.push('/');
    } else if (isAdmin) {
      fetchStats();
    }
  }, [isAdmin, isLoading, router]);

  const fetchStats = async () => {
    try {
      // Fetch total users
      const { count: totalUsers } = await supabase
        .from('users')
        .select('*', { count: 'exact', head: true });

      // Fetch total subscribers
      const { count: totalSubscribers } = await supabase
        .from('users')
        .select('*', { count: 'exact', head: true })
        .eq('is_subscribed', true);

      // Fetch total sessions
      const { count: totalSessions } = await supabase
        .from('dream_sessions')
        .select('*', { count: 'exact', head: true });

      // Fetch total tokens spent
      const { data: users, error } = await supabase
        .from('users')
        .select('token_transactions');

      if (error) {
        throw error;
      }

      let totalTokensSpent = 0;
      users.forEach(user => {
        if (user.token_transactions && Array.isArray(user.token_transactions)) {
          user.token_transactions.forEach((transaction: { amount: number }) => {
            totalTokensSpent += Math.abs(transaction.amount);
          });
        }
      });

      setStats({
        totalUsers: totalUsers || 0,
        totalSubscribers: totalSubscribers || 0,
        totalSessions: totalSessions || 0,
        totalTokensSpent,
      });
    } catch (error) {
      console.error('Error fetching stats:', error);
    }
  };

  if (isLoading) {
    return <LoadingOverlay visible={true} />;
  }

  if (!isAdmin) {
    return null; // Non-admin users are redirected
  }

  return (
    <AppShell padding="md">
      <AppShellHeader p="xs">
        <Title order={3}>Admin Dashboard</Title>
      </AppShellHeader>

      <AppShellNavbar p="xs" zIndex={-1} style={{paddingTop: 75, background: 'blue', color: 'white'}}>
        <Button variant="subtle" fullWidth mt="md">
          Dashboard
        </Button>
        <Button variant="subtle" fullWidth mt="sm">
          User Management
        </Button>
        <Button variant="subtle" fullWidth mt="sm">
          Reports
        </Button>
      </AppShellNavbar>

      <AppShellMain>
        <Container>
          <Stack>
            <Title order={4}>Key Metrics</Title>
            <Group>
              <StatsCard title="Total Users" stat={stats.totalUsers} />
              <StatsCard title="Total Subscribers" stat={stats.totalSubscribers} />
              <StatsCard title="Total Sessions" stat={stats.totalSessions} />
              <StatsCard title="Total Tokens Spent" stat={stats.totalTokensSpent} />
            </Group>

            {successMessage && (
              <Notification
                icon={<IconCheck size={18} />}
                color="teal"
                title="Success"
                onClose={() => setSuccessMessage('')}
              >
                {successMessage}
              </Notification>
            )}
          </Stack>
        </Container>
      </AppShellMain>
    </AppShell>
  );
};

export default AdminSettings;

================
File: app/api/auth/[kindeAuth]/route.ts
================
import {handleAuth} from "@kinde-oss/kinde-auth-nextjs/server";
export const GET = handleAuth();

================
File: app/api/cron/monthly-token-distribution/route.ts
================
// app/api/cron/monthly-token-distribution/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_KEY!
);

export async function GET(req: NextRequest) {
  // Verify the request is coming from the cron job
  const authHeader = req.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    // Fetch all subscribed users
    const { data: subscribedUsers, error: fetchError } = await supabase
      .from('users')
      .select('id, token_balance')
      .eq('is_subscribed', true);

    if (fetchError) {
      throw new Error(`Failed to fetch subscribed users: ${fetchError.message}`);
    }

    // update token balance for each subscribed user
    const updatePromises = subscribedUsers.map(user => 
      supabase
        .from('users')
        .update({ token_balance: user.token_balance + 1500 })
        .eq('id', user.id)
    );

    await Promise.all(updatePromises);

    console.log(`Updated token balance for ${subscribedUsers.length} users`);

    return NextResponse.json({
      message: `Successfully updated token balance for ${subscribedUsers.length} users`,
      success: true
    });
  } catch (error) {
    console.error('Error in monthly token distribution:', error);
    return NextResponse.json(
      { error: 'Failed to process monthly token distribution' },
      { status: 500 }
    );
  }
}

================
File: app/api/dalle/route.ts
================
import { NextResponse } from 'next/server';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_KEY!
);

export async function POST(req: Request) {
  try {
    const { prompt, userId } = await req.json();

    if (!prompt || !userId) {
      return NextResponse.json({ error: 'Prompt and userId are required' }, { status: 400 });
    }

    const image = await openai.images.generate({
      model: "dall-e-3",
      prompt: prompt,
      n: 1,
      size: "1024x1024",
      response_format: "b64_json"
    });

    const base64Image = image.data[0].b64_json;

    if (!base64Image) {
      throw new Error('Failed to generate image: No base64 data received');
    }

    // Convert base64 to buffer
    const imageBuffer = Buffer.from(base64Image, 'base64');

    // Generate a unique filename
    const filename = `dream_image_${Date.now()}.png`;
    const filePath = `${userId}/${filename}`;

    // Upload to Supabase storage
    const { data, error } = await supabase.storage
      .from('dream-images')
      .upload(filePath, imageBuffer, {
        contentType: 'image/png'
      });

    if (error) throw error;

    // Get public URL
    const { data: publicUrlData } = supabase.storage
      .from('dream-images')
      .getPublicUrl(filePath);

    return NextResponse.json({ imageUrl: publicUrlData.publicUrl });
  } catch (error) {
    console.error('Error:', error);
    return NextResponse.json({ error: 'Failed to generate and save image' }, { status: 500 });
  }
}

================
File: app/api/dreamy/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_KEY!
);

const ASSISTANT_ID = 'asst_7Y5Exec5MCiqPUKWn12cqDA8';

export async function POST(req: NextRequest) {
  try {
    const { prompt, userId, sessionId } = await req.json();

    if (!prompt || !userId) {
      return NextResponse.json({ error: 'Prompt and userId are required' }, { status: 400 });
    }

    // Create a thread
    const thread = await openai.beta.threads.create();

    // Add the user's prompt to the thread
    await openai.beta.threads.messages.create(thread.id, {
      role: "user",
      content: prompt
    });

    // Run the assistant
    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: ASSISTANT_ID
    });

    // Wait for the run to complete
    let runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
    while (runStatus.status !== 'completed') {
      await new Promise(resolve => setTimeout(resolve, 1000));
      runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
    }

    // Retrieve the messages
    const messages = await openai.beta.threads.messages.list(thread.id);

    // Get the last assistant message
    const lastAssistantMessage = messages.data
      .filter(message => message.role === 'assistant')
      .pop();

    if (lastAssistantMessage) {
      const responseContent = lastAssistantMessage.content.reduce((acc, content) => {
        if (content.type === 'text') {
          return acc + content.text.value;
        }
        return acc;
      }, '');

      let newSessionId = sessionId;

      // Save or update the dream session
      if (sessionId) {
        // Fetch the existing session
        const { data: existingSession, error: fetchError } = await supabase
          .from('dream_sessions')
          .select('dream_text, interpretation')
          .eq('id', sessionId)
          .single();

        if (fetchError) {
          console.error('Error fetching existing session:', fetchError);
          return NextResponse.json({ error: 'Failed to update session' }, { status: 500 });
        }

        // Update existing session
        const { error: updateError } = await supabase
          .from('dream_sessions')
          .update({
            dream_text: `${existingSession.dream_text}\n\n${prompt}`,
            interpretation: `${existingSession.interpretation}\n\n${responseContent}`
          })
          .eq('id', sessionId);

        if (updateError) {
          console.error('Error updating dream session:', updateError);
          return NextResponse.json({ error: 'Failed to update session' }, { status: 500 });
        }
      } else {
        // Create new session
        const { data: insertedSession, error: insertError } = await supabase
          .from('dream_sessions')
          .insert({
            user_id: userId,
            dream_text: prompt,
            interpretation: responseContent
          })
          .select()
          .single();

        if (insertError) {
          console.error('Error saving dream session:', insertError);
          return NextResponse.json({ error: 'Failed to create new session' }, { status: 500 });
        }

        newSessionId = insertedSession.id;
      }

      return NextResponse.json({ 
        reply: responseContent,
        sessionId: newSessionId
      });
    } else {
      throw new Error('No response from assistant');
    }
  } catch (error) {
    console.error('Error:', error);
    return NextResponse.json({ error: 'Failed to get assistant response' }, { status: 500 });
  }
}

================
File: app/api/payment-success/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { createClient } from '@supabase/supabase-js';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_KEY!
);

export async function POST(req: NextRequest) {
  const rawBody = await req.text();
  const sig = req.headers.get('stripe-signature') as string;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      rawBody,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err) {
    console.error('Webhook signature verification failed:', err instanceof Error ? err.message : 'Unknown Error');
    return NextResponse.json(
      { error: `Webhook Error: ${err instanceof Error ? err.message : 'Unknown Error'}` },
      { status: 400 }
    );
  }

  console.log('Received event:', event.type);

  if (event.type === 'checkout.session.completed') {
    const session = event.data.object as Stripe.Checkout.Session;
    
    const userEmail = session.customer_email || 'gregory.reeves@teachstone.com';

    console.log('Processing completed checkout for:', userEmail);

    try {
      // Fetch the user from Supabase
      const { data: userData, error: userError } = await supabase
        .from('users')
        .select('id, token_balance')
        .eq('email', userEmail)
        .single();

      if (userError || !userData) {
        console.error('User not found:', userEmail);
        throw new Error('User not found');
      }

      // Update the user's subscription status and token balance
      const newBalance = userData.token_balance + 1500;
      const { error: updateError } = await supabase
        .from('users')
        .update({ 
          is_subscribed: true,
          token_balance: newBalance
        })
        .eq('id', userData.id);

      if (updateError) {
        console.error('Failed to update user data:', updateError);
        throw new Error('Failed to update user data');
      }

      console.log('Successfully updated user data for:', userEmail);
      return NextResponse.json({ received: true, processed: true });
    } catch (error) {
      console.error('Error processing webhook:', error);
      return NextResponse.json({ error: 'Failed to process payment' }, { status: 500 });
    }
  } else {
    console.log('Unhandled event type:', event.type);
    return NextResponse.json({ received: true, processed: false });
  }
}

================
File: app/api/payment-success-1000/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { createClient } from '@supabase/supabase-js';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_KEY!
);

export async function POST(req: NextRequest) {
  const rawBody = await req.text();
  const sig = req.headers.get('stripe-signature') as string;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      rawBody,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err) {
    console.error('Webhook signature verification failed:', err instanceof Error ? err.message : 'Unknown Error');
    return NextResponse.json(
      { error: `Webhook Error: ${err instanceof Error ? err.message : 'Unknown Error'}` },
      { status: 400 }
    );
  }

  console.log('Received event:', event.type);

  if (event.type === 'checkout.session.completed') {
    const session = event.data.object as Stripe.Checkout.Session;
    
    // For testing, you might need to retrieve the customer email differently
    // as the test event might not include a customer email
    const userEmail = session.customer_email || 'gregory.reeves@teachstone.com';

    console.log('Processing completed checkout for:', userEmail);

    try {
      // Fetch the user from Supabase
      const { data: userData, error: userError } = await supabase
        .from('users')
        .select('id, token_balance')
        .eq('email', userEmail)
        .single();

      if (userError || !userData) {
        console.error('User not found:', userEmail);
        throw new Error('User not found');
      }

      // Update the user's subscription status and token balance
      const newBalance = userData.token_balance + 1000;
      const { error: updateError } = await supabase
        .from('users')
        .update({ 
          token_balance: newBalance
        })
        .eq('id', userData.id);

      if (updateError) {
        console.error('Failed to update user data:', updateError);
        throw new Error('Failed to update user data');
      }

      console.log('Successfully updated user data for:', userEmail);
      return NextResponse.json({ received: true, processed: true });
    } catch (error) {
      console.error('Error processing webhook:', error);
      return NextResponse.json({ error: 'Failed to process payment' }, { status: 500 });
    }
  } else {
    console.log('Unhandled event type:', event.type);
    return NextResponse.json({ received: true, processed: false });
  }
}

================
File: app/api/payment-success-1500/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { createClient } from '@supabase/supabase-js';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_KEY!
);

export async function POST(req: NextRequest) {
  const rawBody = await req.text();
  const sig = req.headers.get('stripe-signature') as string;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      rawBody,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err) {
    console.error('Webhook signature verification failed:', err instanceof Error ? err.message : 'Unknown Error');
    return NextResponse.json(
      { error: `Webhook Error: ${err instanceof Error ? err.message : 'Unknown Error'}` },
      { status: 400 }
    );
  }

  console.log('Received event:', event.type);

  if (event.type === 'checkout.session.completed') {
    const session = event.data.object as Stripe.Checkout.Session;
    
    // For testing, you might need to retrieve the customer email differently
    // as the test event might not include a customer email
    const userEmail = session.customer_email || 'gregory.reeves@teachstone.com';

    console.log('Processing completed checkout for:', userEmail);

    try {
      // Fetch the user from Supabase
      const { data: userData, error: userError } = await supabase
        .from('users')
        .select('id, token_balance')
        .eq('email', userEmail)
        .single();

      if (userError || !userData) {
        console.error('User not found:', userEmail);
        throw new Error('User not found');
      }

      // Update the user's subscription status and token balance
      const newBalance = userData.token_balance + 1500;
      const { error: updateError } = await supabase
        .from('users')
        .update({ 
          token_balance: newBalance
        })
        .eq('id', userData.id);

      if (updateError) {
        console.error('Failed to update user data:', updateError);
        throw new Error('Failed to update user data');
      }

      console.log('Successfully updated user data for:', userEmail);
      return NextResponse.json({ received: true, processed: true });
    } catch (error) {
      console.error('Error processing webhook:', error);
      return NextResponse.json({ error: 'Failed to process payment' }, { status: 500 });
    }
  } else {
    console.log('Unhandled event type:', event.type);
    return NextResponse.json({ received: true, processed: false });
  }
}

================
File: app/api/payment-success-500/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { createClient } from '@supabase/supabase-js';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_KEY!
);

export async function POST(req: NextRequest) {
  const rawBody = await req.text();
  const sig = req.headers.get('stripe-signature') as string;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      rawBody,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err) {
    console.error('Webhook signature verification failed:', err instanceof Error ? err.message : 'Unknown Error');
    return NextResponse.json(
      { error: `Webhook Error: ${err instanceof Error ? err.message : 'Unknown Error'}` },
      { status: 400 }
    );
  }

  console.log('Received event:', event.type);

  if (event.type === 'checkout.session.completed') {
    const session = event.data.object as Stripe.Checkout.Session;
    
    // For testing, you might need to retrieve the customer email differently
    // as the test event might not include a customer email
    const userEmail = session.customer_email || 'gregory.reeves@teachstone.com';

    console.log('Processing completed checkout for:', userEmail);

    try {
      // Fetch the user from Supabase
      const { data: userData, error: userError } = await supabase
        .from('users')
        .select('id, token_balance')
        .eq('email', userEmail)
        .single();

      if (userError || !userData) {
        console.error('User not found:', userEmail);
        throw new Error('User not found');
      }

      // Update the user's subscription status and token balance
      const newBalance = userData.token_balance + 500;
      const { error: updateError } = await supabase
        .from('users')
        .update({ 
          token_balance: newBalance
        })
        .eq('id', userData.id);

      if (updateError) {
        console.error('Failed to update user data:', updateError);
        throw new Error('Failed to update user data');
      }

      console.log('Successfully updated user data for:', userEmail);
      return NextResponse.json({ received: true, processed: true });
    } catch (error) {
      console.error('Error processing webhook:', error);
      return NextResponse.json({ error: 'Failed to process payment' }, { status: 500 });
    }
  } else {
    console.log('Unhandled event type:', event.type);
    return NextResponse.json({ received: true, processed: false });
  }
}

================
File: app/api/process-query/route.ts
================
// app/api/process-query/route.ts
import { NextResponse } from 'next/server';
import { processTokenTransaction } from '@/components/token system/TokenSystem';
import { hasEnoughTokens } from '@/components/utils/tokenUtils/TokenUtility';
import { createClient } from '@supabase/supabase-js';
import { User } from '@/components/utils/tokenUtils/types';

// Initialize Supabase client
const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

export async function POST(request: Request) {
  const { userId, query } = await request.json();

  // Fetch user from database
  const { data: user, error } = await supabase
    .from('users')
    .select('id, token_balance')
    .eq('id', userId)
    .single();

  if (error || !user) {
    return NextResponse.json(false, { status: 404 });
  }

  if (!hasEnoughTokens(user as User, query)) {
    return NextResponse.json(false, { status: 402 });
  }

  const success = await processTokenTransaction(userId, query);

  return NextResponse.json(success);
}

================
File: app/api/test/route.ts
================
import { NextResponse } from 'next/server';

   export const runtime = 'edge';

   export async function GET() {
     return NextResponse.json({ message: 'Test route is working' });
   }

================
File: app/chat/page.module.css
================
.scrollbar {

    &,
    &:hover {
      background-color: transparent;
    }

    padding-left: 5px;
    border-radius: 25px;
  
    &[data-orientation='vertical'] .thumb {
      background-color: rgba(179, 229, 252, 0.8);
    }
  }
  
  .corner {
    background-color: transparent;
    opacity: 0;
  }

================
File: app/chat/page.tsx
================
import dynamic from 'next/dynamic'

const ClientChat = dynamic(() => import('../../components/chat/ChatComponent'), { ssr: false })

export default function ChatPage() {
  return <ClientChat />
}

================
File: app/payment-complete/page.tsx
================
'use client'

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';

export default function PaymentComplete() {
  const router = useRouter();

  useEffect(() => {
    // Redirect to the main app page after a short delay
    const timer = setTimeout(() => {
      router.push('/chat'); 
    }, 5000);

    return () => clearTimeout(timer);
  }, [router]);

  return (
    <div>
      <h1>Payment Successful!</h1>
      <p>Your subscription has been activated and tokens have been added to your account.</p>
      <p>You will be redirected to the main app in a few seconds...</p>
    </div>
  );
}

================
File: app/globals.css
================
:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}

================
File: app/layout.tsx
================
import '@mantine/core/styles.css';
import { ColorSchemeScript, MantineProvider } from '@mantine/core';
import { Shadows_Into_Light_Two } from 'next/font/google';

const shadows_Into_Light_Two = Shadows_Into_Light_Two({ weight: '400', subsets: ['latin'] });

export const metadata = {
  title: 'Dream-San',
  description: 'Specialized AI for Dream Interpretation.',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <head>
        <ColorSchemeScript />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
      </head>
      <body className={shadows_Into_Light_Two.className}>
        <MantineProvider
          theme={{
            fontSizes: {
              xs: '0.75rem',
              sm: '0.875rem',
              md: '1rem',
              lg: '1.125rem',
              xl: '1.25rem',
            },
            breakpoints: {
              xs: '30em',
              sm: '48em',
              md: '64em',
              lg: '74em',
              xl: '90em',
            },
          }}
        >
       {children}
        </MantineProvider>
      </body>
    </html>
  );
}

================
File: app/page.module.css
================
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition: background 0.2s, color 0.2s, border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 180px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}

================
File: app/page.tsx
================
import Image from "next/image";
import styles from "./page.module.css";
import AuthForm from "@/components/auth/authForm";

export default function Home() {
  return (
    <>
      <AuthForm/>
    </>
  );
}

================
File: components/auth/authForm.tsx
================
'use client'
import React, { useState } from 'react';
import {
  Button,
  Box,
  Paper,
  Text,
  Flex,
  Alert,
  Center,
  Container,
  useMantineTheme,
  Image,
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { useRouter } from 'next/navigation';
import { supabase } from '../../supabase/supabaseClient';
import { useMediaQuery } from '@mantine/hooks';
import dreamsanbg from '../../app/public/dream-san-bg-t-2.png'
import google from '../../app/public/google.png'
import apple from "../../app/public/apple.png"
import twitter from "../../app/public/twitter.png"
import NextImage from 'next/image'
import {RegisterLink, LoginLink} from "@kinde-oss/kinde-auth-nextjs/components";


type AuthMode = 'signIn' | 'signUp';

const AuthForm: React.FC = () => {
  const [authMode, setAuthMode] = useState<AuthMode>('signIn');
  const [email, setEmail] = useState<string>('');
  const [password, setPassword] = useState<string>('');
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();
  const theme = useMantineTheme();
  const isMobileOrTablet = useMediaQuery('(max-width: 1024px)');
  const isNarrowMobile = useMediaQuery('(max-width: 320px)');

  return (
    <Center 
      h="100vh" 
      p={isMobileOrTablet ? 'xs' : 'lg'} 
      style={{
        overflow: 'hidden',
        background: 'linear-gradient(135deg, #ffd54f 0%, #ff8a65 25%, #7e57c2 50%, #5c6bc0 75%, #42a5f5 100%)'
      }}
    >
      {!isMobileOrTablet && (
        <Box
          style={{
            marginLeft: -20,
            width: '50vw', 
            height: '100vh', 
            display: 'flex',
            justifyContent: 'flex-start', 
            alignItems: 'flex-start',
          }}
        >
          <Image
            component={NextImage}
            h='100vh'
            width={1200}
            src={dreamsanbg}
            alt="dreamsanbg"
            style={{
              margin: 0,
              padding: 0,
              display: 'block', 
            }}
          />
        </Box>
      )}
      <Container 
        size={isMobileOrTablet ? '100%' : 'xs'} 
        p={0}
        style={{
          width: isMobileOrTablet ? '100%' : '50%',
        }}
      >
        <Paper radius="md" p={isMobileOrTablet ? 'sm' : 'xl'} bg="rgba(179, 229, 252, 0.8)">
          <Text size={isMobileOrTablet ? (isNarrowMobile ? 'sm' : 'md') : '35px'} fw={500} ta="center" mb="md">
            {authMode === 'signIn' ? 'Welcome to Dream-San' : 'Create an Account'}
          </Text>
          <Text size={isMobileOrTablet ? (isNarrowMobile ? 'xs' : 'sm') : '25px'} fw={500} ta="center" mb="md">Your AI Dream Interpreter</Text>

          {error && (
            <Alert title="Error" color="red" mb="md">
              {error}
            </Alert>
          )}

        <LoginLink postLoginRedirectURL="/chat">Sign in</LoginLink>
        <RegisterLink postLoginRedirectURL="/chat">Sign up</RegisterLink>
        </Paper>
      </Container>
    </Center>
  );
};

export default AuthForm;

================
File: components/chat/ChatComponent.tsx
================
"use client";

import React, { useState, useEffect, useRef } from "react";
import Markdown from "react-markdown";
import DisclaimerModal from "../../components/disclaimer/dislaimer";
import { useRouter } from "next/navigation";
import {
  Container,
  TextInput,
  Box,
  Textarea,
  Button,
  Paper,
  Text,
  ScrollArea,
  Group,
  Loader,
  ThemeIcon,
  MantineProvider,
  AppShell,
  Avatar,
  createTheme,
  Menu,
  Stack,
  Modal,
  Card,
  Image,
  Center,
  AppShellNavbar,
  Burger,
  Flex,
} from "@mantine/core";
import { IconSend, IconMessageCircle, IconMenu2 } from "@tabler/icons-react";
import { supabase } from "../../supabase/supabaseClient";
import { Notifications, notifications } from "@mantine/notifications";
import dreamsanlogo from "../../app/public/dream-san-logo.png";
import NextImage from "next/image";
import { motion, AnimatePresence } from "framer-motion";
import { Lobster } from "next/font/google";
import { useMediaQuery, useDisclosure } from "@mantine/hooks";
import { processTokenTransaction } from "../../components/token system/TokenSystem";
import {
  hasEnoughTokens,
  estimateTokenCost,
} from "../../components/utils/tokenUtils/TokenUtility";
import classes from "./page.module.css";
import { useKindeBrowserClient } from "@kinde-oss/kinde-auth-nextjs";
const lobster = Lobster({ weight: "400", subsets: ["latin"] });

type KindeUser = {
  id: string;
  email: string | null;
  given_name: string | null;
  family_name: string | null;
  picture?: string | null;
  // Include other properties if necessary
};


type Message = {
  id: string;
  content: string;
  user_id: string;
  created_at: string;
  user: {
    id: string;
    email: string;
  };
  imageUrl?: string;
};

type UserData = {
  id: string;
  first_name: string;
  last_name: string;
  email: string;
  token_balance: number;
  tokens_spent: number;
  is_subscribed: boolean;
};

type DreamSession = {
  id: string;
  dream_text: string;
  created_at: string;
  image_url: string;
};


const theme = createTheme({
  primaryColor: "blue",
  fontFamily: "Segoe UI, sans-serif",
  white: "#ffffff",
  black: "#202124",
  components: {
    Button: {
      styles: (theme: any) => ({
        root: {
          borderRadius: theme.radius.md,
          padding: `${theme.spacing.xs} ${theme.spacing.md}`,
          backgroundColor: "#8da0cb",
          color: theme.white,
          transition: "background-color 0.3s ease, box-shadow 0.3s ease",

          "&:hover": {
            backgroundColor: "#7a8bbd",
            boxShadow: theme.shadows.md,
          },

          "&:disabled": {
            backgroundColor: "#a1b1d6",
            color: "#e0e0e0",
          },
        },
      }),
    },
    TextInput: {
      styles: (theme: any) => ({
        root: { flex: 2 },
        input: {
          borderRadius: theme.radius.md,
          backgroundColor: "rgba(255, 255, 255, 0.5)",
          color: theme.black,
          "&::placeholder": {
            color: "rgba(0, 0, 0, 0.5)",
          },
          "&:focus": {
            borderColor: theme.colors.blue[6],
          },
        },
      }),
    },
  },
});

const checkOrCreateUser = async (kindeUser: any) => {
  try {
    const authUser = {
      id: kindeUser.id,
      email: kindeUser.email,
      first_name: kindeUser.given_name || '',
      last_name: kindeUser.family_name || '',
    };

    if (!authUser.email) {
      console.error('Kinde user email is missing.');
      return null;
    }

    console.log('Auth User:', authUser);

    // Check if user exists in the users table using email
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('email', authUser.email.toLowerCase())
      .single();

    if (error && error.code !== 'PGRST116') {
      console.error('Error checking user:', error);
      return null;
    }

    if (data) {
      // User exists, return their data
      console.log('User found in Supabase:', data);
      return data;
    } else {
      // User doesn't exist, create new user
      const newUser = {
        first_name: authUser.first_name,
        last_name: authUser.last_name,
        email: authUser.email.toLowerCase(),
        token_balance: 250,
        tokens_spent: 0,
        is_subscribed: false,
        kinde_user_id: authUser.id,
      };

      const { data: insertedUser, error: insertError } = await supabase
        .from('users')
        .insert(newUser)
        .select('*')
        .single();

      if (insertError) {
        console.error('Error creating user:', insertError);
        return null;
      }

      console.log('New user created in Supabase:', insertedUser);
      return insertedUser;
    }
  } catch (err) {
    console.error('Exception in checkOrCreateUser:', err);
    return null;
  }
};




const Chat: React.FC = (serverUser: any) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState<string>("");
  const [loading, setLoading] = useState<boolean>(true);
  const [sending, setSending] = useState<boolean>(false);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);
  const scrollRef = useRef<HTMLDivElement>(null);
  const [isSubscriptionModalOpen, setIsSubscriptionModalOpen] = useState(false);
  const [isTopUpModalOpen, setIsTopUpModalOpen] = useState(false);
  const [isSubscriptionActive, setIsSubscriptionActive] =
    useState<boolean>(true);
  const [isToppedUp, setIsToppedUp] = useState<boolean>(false);
  const [selectedTopUpAmount, setSelectedTopUpAmount] = useState<number | null>(
    null
  );
  const [confirmationModalOpen, setConfirmationModalOpen] = useState(false);
  const [selectedAmount, setSelectedAmount] = useState<number | null>(null);
  const isMobile = useMediaQuery("(max-width: 768px)");
  const [isNavbarExpanded, setIsNavbarExpanded] = useState(false);
  const [opened, { toggle }] = useDisclosure();
  const [mobileOpened, { toggle: toggleMobile }] = useDisclosure();
  const [desktopOpened, { toggle: toggleDesktop }] = useDisclosure(true);
  const isDesktop = useMediaQuery("(min-width: 768px)");
  const [userData, setUserData] = useState<UserData | null>(null);
  const [dreamHistory, setDreamHistory] = useState<DreamSession[]>([]);
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isFirstMessage, setIsFirstMessage] = useState(true);
  const isTablet = useMediaQuery("(max-width: 1024px) and (max-height: 790px)");
  const [isDisclaimerOpen, setIsDisclaimerOpen] = useState(true);
  const { user, isAuthenticated } = useKindeBrowserClient()


  const truncateTitle = (title: string) => {
    const words = title.split(" ");
    return words.length > 4 ? words.slice(0, 6).join(" ") + "..." : title;
  };

  const router = useRouter();

  const handleManageSubscription = () => {
    setIsLoading(true);
    try {
      // Redirect to the Stripe billing portal
      window.location.href =
        "https://billing.stripe.com/p/login/test_4gw29Sez273BcyQcMM";
    } catch (error) {
      console.error("Error redirecting to subscription management:", error);
      notifications.show({
        title: "Error",
        message:
          "Failed to open subscription management page. Please try again.",
        color: "red",
      });
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    const fetchUserAndData = async () => {
      setLoading(true);
      console.log('USER:', user);
  
      try {
        if (isAuthenticated && user) {
          // Kinde user is authenticated
          const authUser = user;
  
          // Check if user exists in the users table or create a new entry
          const userData = await checkOrCreateUser(authUser);
          if (userData && userData.id) {
            setUserData(userData);
            setCurrentUserId(userData.id); // Use Supabase user ID
            console.log('Current User ID:', userData.id);
  
            // Set the subscription status based on the is_subscribed field
            setIsSubscriptionActive(userData.is_subscribed);
  
            // Fetch dream history from Supabase using Supabase user ID
            const { data: dreamHistoryData, error: dreamHistoryError } =
              await supabase
                .from('dream_sessions')
                .select('id, dream_text, created_at, image_url')
                .eq('user_id', userData.id) // Use Supabase user ID
                .order('created_at', { ascending: false });
  
            if (dreamHistoryError) {
              throw dreamHistoryError;
            }
  
            setDreamHistory(dreamHistoryData || []);
          } else {
            // Handle case where userData is null or userData.id is undefined
            console.error('User data not found or userData.id is undefined.');
            notifications.show({
              title: 'Error',
              message: 'Failed to load user data.',
              color: 'red',
            });
          }
  
          // Don't automatically set active session or load messages
          setActiveSessionId(null);
          setMessages([]);
        } else {
          // User is not authenticated
          console.log('No authenticated user found');
          setCurrentUserId(null);
          setUserData(null);
          setIsSubscriptionActive(false);
          setMessages([]);
          setDreamHistory([]);
          setActiveSessionId(null);
        }
      } catch (error) {
        console.error('Error fetching user data and history:', error);
        notifications.show({
          title: 'Error',
          message: 'Failed to load user data and dream history.',
          color: 'red',
        });
      } finally {
        setLoading(false);
      }
    };
  
    fetchUserAndData();
  }, [isAuthenticated, user]);
  

  const handleLogout = () => {
 
  }

  const handleDisclaimerClose = () => {
    setIsDisclaimerOpen(false);
    localStorage.setItem("hasSeenDisclaimer", "true");
  };

  const loadDreamSession = async (sessionId: string) => {
    setLoading(true);
    try {
      const { data: sessionData, error: sessionError } = await supabase
        .from("dream_sessions")
        .select("messages, image_url")
        .eq("id", sessionId)
        .single();

      if (sessionError) {
        throw sessionError;
      }

      if (sessionData && sessionData.messages) {
        const formattedMessages: Message[] = sessionData.messages.flat();

        // Ensure the image URL is set for the first assistant message
        const firstAssistantMessageIndex = formattedMessages.findIndex(
          (msg) => msg.user_id === "assistant"
        );
        if (firstAssistantMessageIndex !== -1) {
          formattedMessages[firstAssistantMessageIndex].imageUrl =
            sessionData.image_url;
        }

        setMessages(formattedMessages);
        setActiveSessionId(sessionId);
      }
    } catch (error) {
      console.error("Error loading dream session:", error);
      notifications.show({
        title: "Error",
        message: "Failed to load dream session.",
        color: "red",
      });
    } finally {
      setLoading(false);
      scrollToBottom();
    }
  };

  const scrollToBottom = () => {
    scrollRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  const handleSendMessage = async () => {
    if (newMessage.trim() === "") return;
    setSending(true);

    if (!currentUserId || !userData) {
      notifications.show({
        title: "Unauthorized",
        message: "You must be signed in to send messages.",
        color: "red",
      });
      setSending(false);
      return;
    }

    try {
      // Process token transaction
      const transactionSuccess = await processTokenTransaction(
        currentUserId,
        newMessage
      );
      if (!transactionSuccess) {
        throw new Error("Insufficient tokens");
      }

      let imageUrl: string | undefined;

      // Generate and save DALL-E image only if it's a new session (no activeSessionId)
      if (!activeSessionId) {
        const imageResponse = await fetch("/api/dalle", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prompt: newMessage, userId: currentUserId }),
        });
        if (imageResponse.ok) {
          const imageData = await imageResponse.json();
          imageUrl = imageData.imageUrl;
        }
      }

      // Send message to API
      const response = await fetch("/api/dreamy", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: newMessage,
          userId: currentUserId,
          sessionId: activeSessionId,
          imageUrl: imageUrl,
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to get assistant response");
      }

      const data = await response.json();

      // Create message objects
      const userMessage = {
        id: Date.now().toString(),
        content: newMessage,
        user_id: currentUserId,
        created_at: new Date().toISOString(),
        user: { id: currentUserId, email: userData.email },
      };

      const assistantMessage = {
        id: (Date.now() + 1).toString(),
        content: data.reply,
        user_id: "assistant",
        created_at: new Date().toISOString(),
        user: { id: "assistant", email: "assistant@example.com" },
        imageUrl: imageUrl,
      };

      // First, get the current messages array
      const { data: currentSessionData, error: fetchError } = await supabase
        .from("dream_sessions")
        .select("messages")
        .eq("id", data.sessionId)
        .single();

      if (fetchError && fetchError.code !== "PGRST116") {
        throw fetchError;
      }

      // Prepare the new messages array
      const updatedMessages = currentSessionData?.messages || [];
      updatedMessages.push(userMessage, assistantMessage);

      // Update or create session in Supabase
      const { data: sessionData, error: sessionError } = await supabase
        .from("dream_sessions")
        .upsert(
          {
            id: data.sessionId,
            user_id: currentUserId,
            messages: updatedMessages,
            image_url: imageUrl,
          },
          { onConflict: "id" }
        );

      if (sessionError) {
        throw sessionError;
      }

      // Add messages to UI
      setMessages((prev) => [...prev, userMessage, assistantMessage]);

      // Set the active session ID
      setActiveSessionId(data.sessionId);

      // Update user's token balance in the UI
      const tokenCost = estimateTokenCost(newMessage);
      setUserData((prevData) => ({
        ...prevData!,
        token_balance: prevData!.token_balance - tokenCost,
      }));

      // Refresh dream history
      await refreshDreamHistory();

      // Clear input and scroll to bottom
      setNewMessage("");
      scrollToBottom();
    } catch (error) {
      console.error("Error sending message:", error);
      notifications.show({
        title: "Error",
        message: "Failed to send message. Please try again.",
        color: "red",
      });
    } finally {
      setSending(false);
    }
  };

  const refreshDreamHistory = async () => {
    const { data: newHistory, error } = await supabase
      .from("dream_sessions")
      .select("id, dream_text, created_at, image_url") // Add image_url here
      .eq("user_id", currentUserId)
      .order("created_at", { ascending: false });

    if (!error) {
      setDreamHistory(newHistory || []);
    } else {
      console.error("Error refreshing dream history:", error);
    }
  };


  return (
    <MantineProvider theme={theme}>
      <Notifications />
      <AppShell
        padding="md"
        header={{ height: 60 }}
        navbar={{
          width: 250,
          breakpoint: "sm",
          collapsed: { desktop: !desktopOpened, mobile: !mobileOpened },
        }}
        styles={(theme) => ({
          header: {
            backgroundColor: "rgba(179, 229, 252, 0.8)",
            borderBottom: "1px solid #9fa8da",
          },
          main: {
            background:
              "linear-gradient(135deg, #e0f7fa 0%, #b3e5fc 25%, #9fa8da 50%, #b39ddb 75%, #d1c4e9 100%)",
          },
        })}
      >
        <AppShell.Header>
          <Container size="xxl" h="100%" w="100%">
            <Group justify="space-between" h="100%" w="100%">
              <Group>
                <Burger
                  opened={mobileOpened}
                  onClick={toggleMobile}
                  hiddenFrom="sm"
                  size="sm"
                />
                <Burger
                  opened={desktopOpened}
                  onClick={toggleDesktop}
                  visibleFrom="md"
                  size="sm"
                />
                <Stack gap="0px" align="flex-start" justify="center" h="100%">
                  <Text
                    className={lobster.className}
                    size="xl"
                    fw={700}
                    style={{
                      background:
                        "linear-gradient(315deg, #b3e5fc 0%, #9fa8da 50%, #b39ddb 100%)",
                      WebkitBackgroundClip: "text",
                      WebkitTextFillColor: "transparent",
                      backgroundClip: "text",
                      color: "transparent",
                      display: "inline-block",
                      marginLeft: isMobile ? "60px" : "0",
                    }}
                  >
                    Dream-San
                  </Text>
                  <Text
                    size="sm"
                    hiddenFrom="sm"
                    style={{
                      marginLeft: "60px",
                      fontSize: "12px",
                      opacity: 0.7,
                    }}
                  >
                    Token Balance: {userData?.token_balance}
                  </Text>
                </Stack>
              </Group>
              <Group>
                <Box
                  hiddenFrom="sm"
                  style={{
                    position: "absolute",
                    right: "1rem",
                    top: "50%",
                    transform: "translateY(-50%)",
                  }}
                >
                  <Menu>
                    <Menu.Target>
                      <Avatar
                        color="white"
                        radius="xl"
                        style={{
                          transition: "all 0.2s ease-in-out",
                          cursor: "pointer",
                          border: "2.5px solid rgba(255, 255, 255, 0.2)",
                        }}
                      >
                        <Text size="25px">
                          {userData?.first_name
                            ? userData.first_name[0].toUpperCase()
                            : "U"}
                        </Text>
                      </Avatar>
                    </Menu.Target>
                    <Menu.Dropdown>
                      <Menu.Label>
                        <Text size="xl">
                          User: {userData?.first_name} {userData?.last_name}
                        </Text>
                      </Menu.Label>
                      <Menu.Label>
                        <Flex direction="row" align="center" gap="10px">
                          <Text size="xl">Subscribed: </Text>
                          <Text
                            size="xl"
                            span
                            c={userData?.is_subscribed ? "green" : "red"}
                            fw={600}
                          >
                            {userData?.is_subscribed ? "Yes" : "No"}
                          </Text>
                        </Flex>
                      </Menu.Label>
                      <Menu.Item
                        onClick={() => setIsSubscriptionModalOpen(true)}
                      >
                        <Text size="xl">Manage Subscription</Text>
                      </Menu.Item>
                      <Menu.Item>
                        <Stack align="center">
                          <Container
                            onClick={() => setIsTopUpModalOpen(true)}
                            style={{
                              backgroundColor: "rgba(179, 229, 252, 0.8)",
                              borderRadius: "8px",
                              padding: "10px 20px",
                              cursor: "pointer",
                              transition: "background-color 0.3s ease",
                              display: "flex",
                              justifyContent: "center",
                              alignItems: "center",
                              width: "100%",
                            }}
                            styles={(theme) => ({
                              root: {
                                "&:hover": {
                                  backgroundColor: theme.colors.blue[1],
                                },
                                "&:active": {
                                  backgroundColor: theme.colors.blue[2],
                                },
                              },
                            })}
                          >
                            <Text
                              size="25px"
                              fw={500}
                              span
                              style={{ color: "#2c2c2c" }}
                            >
                              Top Up
                            </Text>
                          </Container>
                        </Stack>
                      </Menu.Item>
                      <Menu.Item>
                        <Container
                          onClick={handleLogout}
                          size="lg"
                          style={{
                            backgroundColor: "red",
                            borderRadius: "8px",
                            padding: "10px 20px",
                            cursor: "pointer",
                            transition: "background-color 0.3s ease",
                            display: "flex",
                            justifyContent: "center",
                            alignItems: "center",
                            width: "100%",
                          }}
                          styles={(theme) => ({
                            root: {
                              "&:hover": {
                                backgroundColor: theme.colors.blue[1],
                              },
                              "&:active": {
                                backgroundColor: theme.colors.blue[2],
                              },
                            },
                          })}
                        >
                          <Text
                            size="25px"
                            fw={500}
                            span
                            style={{ color: "black" }}
                          >
                            Logout
                          </Text>
                        </Container>
                      </Menu.Item>
                    </Menu.Dropdown>
                  </Menu>
                </Box>
                <Group visibleFrom="sm">
                  <Text size="xl" mr="md">
                    Token Balance: {userData?.token_balance}
                  </Text>
                  <Menu>
                    <Menu.Target>
                      <div
                        style={{
                          display: "inline-block",
                          borderRadius: "60%",
                          overflow: "hidden",
                        }}
                        onMouseEnter={(e) => {
                          const avatar = e.currentTarget
                            .firstElementChild as HTMLElement;
                          if (avatar) {
                            avatar.style.boxShadow = `
                      0 0 20px 10px rgba(255, 255, 255, 0.8),
                      0 0 40px 20px rgba(255, 255, 255, 0.6),
                      0 0 60px 30px rgba(255, 255, 255, 0.4),
                      0 0 80px 40px rgba(255, 255, 255, 0.2),
                      0 0 100px 50px rgba(255, 255, 255, 0.1)
                    `;
                            avatar.style.border =
                              "2px solid rgba(255, 255, 255, 1)";
                            avatar.style.fontWeight = "700";
                          }
                        }}
                        onMouseLeave={(e) => {
                          const avatar = e.currentTarget
                            .firstElementChild as HTMLElement;
                          if (avatar) {
                            avatar.style.boxShadow = "none";
                            avatar.style.border =
                              "2.5px solid rgba(255, 255, 255, 0.2)";
                            avatar.style.fontWeight = "400";
                          }
                        }}
                      >
                        <Avatar
                          color="white"
                          radius="xl"
                          style={{
                            transition: "all 0.2s ease-in-out",
                            cursor: "pointer",
                          }}
                        >
                          <Text size="25px">
                            {userData?.first_name
                              ? userData.first_name[0].toUpperCase()
                              : "U"}
                          </Text>
                        </Avatar>
                      </div>
                    </Menu.Target>
                    <Menu.Dropdown>
                      <Menu.Label>
                        <Text size="xl">
                          User: {userData?.first_name} {userData?.last_name}
                        </Text>
                      </Menu.Label>
                      <Menu.Label>
                        <Flex direction="row" align="center" gap="10px">
                          <Text size="xl">Subscribed: </Text>
                          <Text
                            size="xl"
                            span
                            c={userData?.is_subscribed ? "green" : "red"}
                            fw={600}
                          >
                            {userData?.is_subscribed ? "Yes" : "No"}
                          </Text>
                        </Flex>
                      </Menu.Label>
                      <Menu.Item
                        onClick={() => setIsSubscriptionModalOpen(true)}
                      >
                        <Text size="xl">Manage Subscription</Text>
                      </Menu.Item>
                      <Menu.Item>
                        <Stack align="center">
                          <Container
                            onClick={() => setIsTopUpModalOpen(true)}
                            style={{
                              backgroundColor: "rgba(179, 229, 252, 0.8)",
                              borderRadius: "8px",
                              padding: "10px 20px",
                              cursor: "pointer",
                              transition: "background-color 0.3s ease",
                              display: "flex",
                              justifyContent: "center",
                              alignItems: "center",
                              width: "100%",
                            }}
                            styles={(theme) => ({
                              root: {
                                "&:hover": {
                                  backgroundColor: theme.colors.blue[1],
                                },
                                "&:active": {
                                  backgroundColor: theme.colors.blue[2],
                                },
                              },
                            })}
                          >
                            <Text
                              size="25px"
                              fw={500}
                              span
                              style={{ color: "#2c2c2c" }}
                            >
                              Top Up
                            </Text>
                          </Container>
                        </Stack>
                      </Menu.Item>
                      <Menu.Item>
                        <Container
                          onClick={handleLogout}
                          size="lg"
                          style={{
                            backgroundColor: "red",
                            borderRadius: "8px",
                            padding: "10px 20px",
                            cursor: "pointer",
                            transition: "background-color 0.3s ease",
                            display: "flex",
                            justifyContent: "center",
                            alignItems: "center",
                            width: "100%",
                          }}
                          styles={(theme) => ({
                            root: {
                              "&:hover": {
                                backgroundColor: theme.colors.blue[1],
                              },
                              "&:active": {
                                backgroundColor: theme.colors.blue[2],
                              },
                            },
                          })}
                        >
                          <Text
                            size="25px"
                            fw={500}
                            span
                            style={{ color: "black" }}
                          >
                            Logout
                          </Text>
                        </Container>
                      </Menu.Item>
                    </Menu.Dropdown>
                  </Menu>
                </Group>
              </Group>
            </Group>
          </Container>
        </AppShell.Header>

        <AppShell.Navbar
          p="md"
          style={{
            backgroundColor: "rgba(179, 229, 252, 0.8)",
            borderRight: "1px solid #9FA8DA",
            transition: "width 0.3s ease",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <Text size="xl" fw={700} mb={15} c="black">
            Dream History
          </Text>
          <Button
            onClick={() => {
              setActiveSessionId(null);
              setMessages([]);
            }}
            fullWidth
            mb={15}
          >
            Start New Dream Session
          </Button>
          <ScrollArea style={{ flex: 1 }} type="auto">
            <Stack gap="5px">
              {dreamHistory.map((dream) => (
                <Button
                  key={dream.id}
                  variant="subtle"
                  fullWidth
                  styles={{
                    root: {
                      justifyContent: "flex-start",
                      padding: "10px",
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                      height: "auto",
                      minHeight: 36,
                      transition: "background-color 0.2s ease",
                      "&:hover": {
                        backgroundColor: "rgba(255, 255, 255, 0.2)",
                      },
                    },
                    label: {
                      color: "black",
                      whiteSpace: "nowrap",
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      width: "100%",
                      textAlign: "left",
                    },
                  }}
                  onClick={() => {
                    loadDreamSession(dream.id);
                  }}
                >
                  <Stack gap="5px">
                    <Text size="xs" fw={700}>
                      {new Date(dream.created_at).toLocaleDateString()}
                    </Text>
                    <Text size="md">{truncateTitle(dream.dream_text)}</Text>
                  </Stack>
                </Button>
              ))}
            </Stack>
          </ScrollArea>
        </AppShell.Navbar>

        <AppShell.Main>
          <Container size="md" py="xl">
            <DisclaimerModal
              opened={isDisclaimerOpen}
              onClose={handleDisclaimerClose}
            />
            <Paper
              shadow="lg"
              radius="md"
              p="md"
              className="custom-scrollbar"
              style={{
                height: "max(80vh, calc(100vh - 160px))",
                display: "flex",
                flexDirection: "column",
                overflow: "visible",
                padding: "1rem",
                boxSizing: "border-box",
                backgroundColor: "rgba(255, 255, 255, 0.2)",
              }}
            >
              <ScrollArea
                type="always"
                offsetScrollbars
                classNames={classes}
                style={{
                  flex: 1,
                  marginBottom: "1rem",
                  backgroundColor: "transparent",
                }}
              >
                {loading ? (
                  <Group justify="center" mt="xl">
                    <Loader color="black" />
                  </Group>
                ) : (
                  messages.map((msg) => (
                    <Group
                      key={msg.id}
                      justify={
                        msg.user_id === currentUserId
                          ? "flex-end"
                          : "flex-start"
                      }
                      gap="xs"
                      mb="xs"
                    >
                      {msg.user_id !== currentUserId && msg.imageUrl && (
                        <Flex
                          justify="center"
                          align="center"
                          style={{ width: "100%", minHeight: 220, gap: "sm" }}
                        >
                          <Image
                            src={msg.imageUrl}
                            alt="Dream visualization"
                            radius="md"
                            width={200}
                            height={200}
                            fit="contain"
                          />
                        </Flex>
                      )}
                      <Paper
                        radius="md"
                        p="xs"
                        bg={
                          msg.user_id === currentUserId
                            ? "rgba(255, 255, 255, 0.5)"
                            : "rgba(179, 229, 252, 0.8)"
                        }
                      >
                        {msg.user_id === currentUserId ? (
                          <Text size="sm">{msg.content}</Text>
                        ) : (
                          <Markdown>{msg.content}</Markdown>
                        )}
                      </Paper>
                    </Group>
                  ))
                )}
                <div ref={scrollRef} />
              </ScrollArea>
              <Group
                align="flex-end"
                w="100%"
                style={{ flexDirection: isMobile ? "column" : "row" }}
              >
                <Textarea
                  placeholder="Type your message..."
                  value={newMessage}
                  onChange={(event) => setNewMessage(event.currentTarget.value)}
                  size="12px"
                  autosize
                  minRows={1}
                  maxRows={7}
                  style={{ width: isMobile ? "100%" : "85%" }}
                  disabled={sending}
                  styles={{
                    input: {
                      borderRadius: "10px",
                      padding: "0.75rem",
                      backgroundColor: "rgba(255, 255, 255, 0.5)",
                      border: "none",
                      height: "42.5px",
                      overflow: "hidden",
                      overflowY: "auto",
                      scrollbarWidth: "none",
                      msOverflowStyle: "none",
                    },
                  }}
                />
                <Button
                  loaderProps={{ size: 35 }}
                  color="#999999"
                  onClick={handleSendMessage}
                  loading={sending}
                  disabled={sending}
                  size="42px"
                  style={{
                    width: isMobile ? "100%" : "auto",
                    flex: isMobile ? "none" : 1.1,
                  }}
                >
                  {isMobile || isTablet ? (
                    <Text size="20px">☁️</Text>
                  ) : (
                    <Text size="20px">☁️ Send</Text>
                  )}
                </Button>
              </Group>
            </Paper>
          </Container>
        </AppShell.Main>

        <Modal
          opened={isSubscriptionModalOpen}
          onClose={() => setIsSubscriptionModalOpen(false)}
          title="Manage Subscription"
        >
          <Stack>
            {isSubscriptionActive ? (
              <Flex direction="row" align="center" gap="10px">
                <Text size="xl">Subscribed: </Text>
                <Text
                  size="xl"
                  span
                  c={userData?.is_subscribed ? "green" : "red"}
                  fw={600}
                >
                  {userData?.is_subscribed ? "Yes" : "No"}
                </Text>
              </Flex>
            ) : (
              <Card shadow="sm" padding="lg" radius="md" withBorder>
                <Card.Section>
                  <Image
                    component={NextImage}
                    src={dreamsanlogo}
                    height={310}
                    width={100}
                    alt="Cloud Heart"
                  />
                </Card.Section>
                <Stack>
                  <Text
                    size="xxl"
                    fw={1000}
                    ta="center"
                    c="black"
                    style={{ paddingTop: "25px" }}
                  >
                    🪙 1500 Tokens 🪙
                  </Text>
                  <Text
                    size="xxl"
                    fw={1000}
                    ta="center"
                    c="black"
                    style={{ paddingTop: "25px" }}
                  >
                    Unlock the mysteries of your subconscious with our exclusive
                    monthly subscription. Receive 30 personalized dream queries
                    each month to delve deeper into your dreams, uncover hidden
                    meanings, and gain profound insights into your inner world.
                    Don't miss the chance to transform your nightly visions into
                    a journey of self-discovery—subscribe today and elevate your
                    dream exploration!
                  </Text>
                </Stack>

                <Button
                  color="blue"
                  fullWidth
                  mt="md"
                  radius="md"
                  onClick={() =>
                    (window.location.href =
                      "https://buy.stripe.com/test_fZedTValBcA72uA9AA")
                  }
                >
                  Activate Subscription
                </Button>
              </Card>
            )}
            <Button
              color="red"
              fullWidth
              onClick={handleManageSubscription}
              styles={(theme) => ({
                root: {
                  "&:hover": {
                    backgroundColor: theme.colors.red[7],
                  },
                },
              })}
            >
              Cancel Subscription
            </Button>
          </Stack>
        </Modal>

        <Modal
          opened={isTopUpModalOpen}
          onClose={() => {
            setIsTopUpModalOpen(false);
            setSelectedAmount(null);
          }}
          title="Top Up Tokens"
        >
          <AnimatePresence mode="wait">
            <motion.div
              key="topup-options"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              transition={{ duration: 0.5, ease: "easeInOut" }}
            >
              {isSubscriptionActive ? (
                <Card shadow="sm" padding="lg" radius="md" withBorder>
                  <Card.Section>
                    <Image
                      component={NextImage}
                      src={dreamsanlogo}
                      height={100}
                      width={100}
                      alt="Cloud Heart"
                    />
                  </Card.Section>
                  <Text
                    size="xxl"
                    fw={1000}
                    ta="center"
                    c="black"
                    style={{ paddingTop: "25px" }}
                  >
                    TOKENS
                  </Text>
                  <Stack mt="md">
                    <Button
                      onClick={() => {
                        setSelectedAmount(1500);
                        setConfirmationModalOpen(true);
                      }}
                      styles={(theme) => ({
                        root: {
                          backgroundColor: theme.colors.blue[6],
                          "&:hover": { backgroundColor: theme.colors.blue[7] },
                        },
                      })}
                    >
                      1500 Tokens
                    </Button>
                    <Button
                      onClick={() => {
                        setSelectedAmount(1000);
                        setConfirmationModalOpen(true);
                      }}
                      styles={(theme) => ({
                        root: {
                          backgroundColor: theme.colors.blue[6],
                          "&:hover": { backgroundColor: theme.colors.blue[7] },
                        },
                      })}
                    >
                      1000 Tokens
                    </Button>
                    <Button
                      onClick={() => {
                        setSelectedAmount(500);
                        setConfirmationModalOpen(true);
                      }}
                      styles={(theme) => ({
                        root: {
                          backgroundColor: theme.colors.blue[6],
                          "&:hover": { backgroundColor: theme.colors.blue[7] },
                        },
                      })}
                    >
                      500 Tokens
                    </Button>
                  </Stack>
                </Card>
              ) : (
                <Card shadow="sm" padding="lg" radius="md" withBorder>
                  <Text size="xl" fw={700} ta="center">
                    Subscribe to purchase tokens
                  </Text>
                </Card>
              )}
            </motion.div>
          </AnimatePresence>
        </Modal>

        <Modal
          opened={confirmationModalOpen}
          onClose={() => setConfirmationModalOpen(false)}
          title="Confirm Purchase"
        >
          <Text size="lg" mb="md">
            Are you sure you want to purchase {selectedAmount} tokens?
          </Text>
          <Group>
            <Button
              onClick={() => {
                let stripeUrl = "";

                // Check the selectedTokenAmount and assign the corresponding Stripe link
                if (selectedAmount === 500) {
                  stripeUrl = "https://buy.stripe.com/aEU29n2NPclfbYI6op";
                } else if (selectedAmount === 1000) {
                  stripeUrl = "https://buy.stripe.com/aEU7tH2NP9930g05km";
                } else if (selectedAmount === 1500) {
                  stripeUrl = "https://buy.stripe.com/dR601f3RT5WR8MwdQT";
                }

                if (stripeUrl) {
                  console.log(
                    `Processing payment for ${selectedAmount} tokens`
                  );
                  setConfirmationModalOpen(false);
                  setIsTopUpModalOpen(false);

                  // Redirect to the Stripe payment link
                  window.location.href = stripeUrl;
                } else {
                  console.error("Invalid token amount selected");
                }
              }}
              color="green"
            >
              Pay for Tokens
            </Button>

            <Button
              onClick={() => setConfirmationModalOpen(false)}
              color="gray"
            >
              No, Cancel
            </Button>
          </Group>
        </Modal>
      </AppShell>
    </MantineProvider>
  );
};

export default Chat;

================
File: components/chat/page.module.css
================
.scrollbar {

    &,
    &:hover {
      background-color: transparent;
    }

    padding-left: 5px;
    border-radius: 25px;
  
    &[data-orientation='vertical'] .thumb {
      background-color: rgba(179, 229, 252, 0.8);
    }
  }
  
  .corner {
    background-color: transparent;
    opacity: 0;
  }

================
File: components/disclaimer/disclaimermodal.module.css
================
/* DisclaimerModal.module.css */

/* Style for the modal title */
.title {
    color: #1976D2;
    font-weight: 700;
    font-size: 1.5rem;
  }
  
  /* Style for the modal body */
  .body {
    background-color: rgba(179, 229, 252, 0.9);
    padding: 20px;
    /* Removed border-radius to prevent conflicts */
  }
  
  /* Style for the content inside the modal */
  .content {
    color: #333;
  }
  
  /* Style for the accept button */
  .acceptButton {
    background-color: #2196F3;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.3s ease;
  }
  
  .acceptButton:hover {
    background-color: #1565C0;
  }

================
File: components/disclaimer/dislaimer.tsx
================
import React from 'react';
import { Modal, Text, Stack, Button, ScrollArea, Group, Loader, Flex, Image, Paper } from '@mantine/core';
import styles from './disclaimermodal.module.css';

interface DisclaimerModalProps {
  opened: boolean;
  onClose: () => void;
}

const DisclaimerModal: React.FC<DisclaimerModalProps> = ({ opened, onClose }) => {
  return (
    <Modal 
      opened={opened} 
      onClose={onClose} 
      title="Dream-San App Disclaimer" 
      size="lg"
      withCloseButton={false}
      closeOnClickOutside={false}
      closeOnEscape={false}
      radius="16px" // Applies a 16px border-radius to the entire modal
      styles={{
        header: {
          backgroundColor: 'rgba(179, 229, 252, 1)', // Opaque background
          padding: '16px 24px', // Optional: Adjust padding as needed
        },
        body: {
          backgroundColor: 'rgba(179, 229, 252, 0.9)', // Semi-transparent body background
          padding: '20px',
        },
      }}
    >
      <div className={styles.content}>
        <ScrollArea
          style={{ height: '400px', marginBottom: '1rem' }} // Adjust height as needed
          styles={(theme) => ({
            root: {
              background: 'transparent', // Transparent outer container
            },
            viewport: {
              background: 'transparent', // Transparent scrollable area
            },
            scrollbar: {
              background: 'transparent', // Transparent scrollbar track
            },
            thumb: {
              backgroundColor: theme.colors.gray[3], // Scrollbar thumb color
              '&:hover': {
                backgroundColor: theme.colors.gray[4], // Darker on hover
              },
            },
            corner: {
              background: 'transparent', // Transparent corner
            },
          })}
        >
          <Stack gap="md">
            <Text>
              Welcome to Dream-San, your AI-powered dream interpretation companion. Before you begin your journey of dream exploration, please read and acknowledge the following disclaimer:
            </Text>
            
            <Text fw={700}>1. Purpose and Limitations:</Text>
            <Text>
              Dream-San is designed for entertainment and self-reflection purposes only. The interpretations provided are generated by artificial intelligence and should not be considered as professional psychological or therapeutic advice.
            </Text>

            <Text fw={700}>2. No Substitute for Professional Help:</Text>
            <Text>
              Our app is not a substitute for professional medical, psychological, or psychiatric treatment. If you are experiencing mental health concerns or recurring distressing dreams, please consult with a qualified healthcare professional.
            </Text>

            <Text fw={700}>3. AI Interpretation:</Text>
            <Text>
              The dream interpretations are generated by AI based on patterns and information it has been trained on. These interpretations may not always be accurate or applicable to your personal situation.
            </Text>

            <Text fw={700}>4. Privacy and Data Use:</Text>
            <Text>
              While we take measures to protect your privacy, please be aware that the dreams you share are processed by our AI system. Do not share sensitive personal information in your dream descriptions.
            </Text>

            <Text fw={700}>5. User Responsibility:</Text>
            <Text>
              Users are responsible for their own actions and decisions based on the app's interpretations. Dream-San and its creators are not liable for any consequences resulting from the use of this app.
            </Text>

            <Text fw={700}>6. Accuracy and Completeness:</Text>
            <Text>
              We strive to provide helpful and insightful interpretations, but we do not guarantee the accuracy, completeness, or usefulness of any interpretation provided by the app.
            </Text>

            <Text fs='italic'>
              By using Dream-San, you acknowledge that you have read, understood, and agree to this disclaimer. If you do not agree with these terms, please do not use the app.
            </Text>
          </Stack>
        </ScrollArea>
        <Button onClick={onClose} fullWidth className={styles.acceptButton}>
          I Understand and Accept
        </Button>
      </div>
    </Modal>
  );
};

export default DisclaimerModal;

================
File: components/StatsCard/StatsCard.tsx
================
import React from 'react';
import { Card, Text, Group, Stack } from '@mantine/core';

interface StatsCardProps {
  title: string;
  stat: string | number;
}

const StatsCard: React.FC<StatsCardProps> = ({ title, stat }) => {
  return (
    <Card shadow="sm" padding="lg" radius="md" withBorder>
      <Group>
        <Stack>
            <Text>{title}</Text>
            <Text size="xl">{stat}</Text>
        </Stack>
      </Group>
    </Card>
  );
};

export default StatsCard;

================
File: components/token system/TokenSystem.ts
================
// tokenSystem.ts
import { supabase } from '../../supabase/supabaseClient';
import { estimateTokenCost } from '../utils/tokenUtils/TokenUtility';

export async function processTokenTransaction(userId: string, query: string): Promise<boolean> {
  const tokenCost = estimateTokenCost(query);

  // Start a Supabase transaction
  const { data, error } = await supabase.rpc('process_token_transaction', {
    p_user_id: userId,
    p_token_cost: tokenCost
  });

  if (error) {
    console.error('Error processing token transaction:', error);
    throw new Error(`Token transaction failed: ${error.message}`);
  }

  return data === true;
}

================
File: components/utils/tokenUtils/TokenUtility.ts
================
// tokenUtils.ts
import { TOKENS_PER_CHARACTER, MIN_TOKENS_PER_QUERY } from '../../../constants/constants';
import { User } from './types'; 

export function estimateTokenCost(query: string): number {
  const estimatedTokens = Math.ceil(query.length * TOKENS_PER_CHARACTER);
  return Math.max(estimatedTokens, MIN_TOKENS_PER_QUERY);
}

export function hasEnoughTokens(user: User, query: string): boolean {
  const estimatedCost = estimateTokenCost(query);
  return user.token_balance >= estimatedCost;  
}

================
File: components/utils/tokenUtils/types.ts
================
// types.ts
export interface User {
    id: string;
    token_balance: number;  
  }
  
  export interface TokenTransaction {
    userId: string;
    amount: number;
    timestamp: Date;
  }

================
File: components/dreamhistorymenu.tsx
================
import React, { useState } from 'react';
import { Paper, Text, ScrollArea, Button, useMantineTheme, Box, Drawer } from '@mantine/core';
import { IconMenu2 } from '@tabler/icons-react';
import { useMediaQuery } from '@mantine/hooks';

interface DreamHistoryItem {
  id: string;
  title: string;
  timestamp: string;
}

const DreamHistoryMenu: React.FC = () => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const theme = useMantineTheme();
  const isMobile = useMediaQuery('(max-width: 768px)');

  const dreamHistory: DreamHistoryItem[] = [
    { id: '1', title: 'Flying over mountains', timestamp: '2023-06-01' },
    { id: '2', title: 'Underwater city with mermaids and talking fish', timestamp: '2023-06-03' },
  ];

  const truncateTitle = (title: string) => {
    const words = title.split(' ');
    if (words.length > 4) {
      return words.slice(0, 4).join(' ') + '...';
    }
    return title;
  };

  const MenuContent = () => (
    <Box p="md">
      <Text size="xl" fw={700} style={{ marginBottom: '15px', color: 'black' }}>
        Dream History
      </Text>
      <ScrollArea style={{ height: isMobile ? 'calc(100vh - 120px)' : 'calc(100% - 60px)' }} type='never'>
        {dreamHistory.map((dream) => (
          <Button
            key={dream.id}
            variant="subtle"
            fullWidth
            styles={(theme) => ({
              root: {
                justifyContent: 'flex-start',
                padding: '10px',
                marginBottom: '10px',
                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                height: 'auto',
                minHeight: 36,
                transition: 'background-color 0.2s ease',
                '&:hover': {
                  backgroundColor: 'rgba(255, 255, 255, 0.2)',
                },
              },
              label: {
                color: 'black',
                whiteSpace: 'nowrap',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                width: '100%',
                textAlign: 'left',
              },
            })}
            onClick={() => {}}
          >
            {truncateTitle(dream.title)}
          </Button>
        ))}
      </ScrollArea>
    </Box>
  );

  if (isMobile) {
    return (
      <>
        <Button
          variant="subtle"
          onClick={() => setIsOpen(true)}
          style={{
            position: 'absolute',
            top: 10,
            left: 5,
          }}
        >
        <IconMenu2 size={24}  />
        </Button>
        <Drawer
          opened={isOpen}
          onClose={() => setIsOpen(false)}
          title="Dream History"
          padding="md"
          size="100%"
          position="left"
        >
          <MenuContent />
        </Drawer>
      </>
    );
  }

  return (
    <Paper
      style={{
        position: 'fixed',
        left: 0,
        top: 60,
        bottom: 0,
        width: isExpanded ? '250px' : '40px',
        transition: 'width 0.3s ease',
        backgroundColor: 'rgba(179, 229, 252, 0.8)',
        borderRight: '1px solid #9fa8da',
        overflow: 'hidden',
        zIndex: 1000,
        display: 'flex',
        flexDirection: 'column',
      }}
      onMouseEnter={() => setIsExpanded(true)}
      onMouseLeave={() => setIsExpanded(false)}
    >
      {isExpanded ? (
        <MenuContent />
      ) : (
        <Button
          variant="subtle"
          style={{
            padding: '10px',
            backgroundColor: 'transparent',
            marginTop: 'auto',
          }}
        >
          <IconMenu2 size={24} />
        </Button>
      )}
    </Paper>
  );
};

export default DreamHistoryMenu;

================
File: constants/constants.ts
================
// constants.ts
export const TOKENS_PER_CHARACTER = 0.2;
export const MIN_TOKENS_PER_QUERY = 10;

================
File: supabase/supabaseClient.js
================
import { createClient } from '@supabase/supabase-js'

export const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY,{
    auth: {
        flowType: 'pkce',
    }
} )

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: middelware.ts
================
export const config = {
  matcher: ["/chat", "/api/chat"],
}

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */
const nextConfig = {
    env: {
        SUPABASE_URL: process.env.SUPABASE_URL,
        SUPABASE_KEY: process.env.SUPABASE_KEY,
        OPENAI_API_KEY: process.env.OPENAI_API_KEY,
        STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
        STRIPE_PUBLISHABLE_KEY: process.env.STRIPE_PUBLISHABLE_KEY,
        STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
        API_URL: process.env.API_URL,
        CRON_SECRET: process.env.CRON_SECRET
      },
};

export default nextConfig;

================
File: package.json
================
{
  "name": "dream-net",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@kinde-oss/kinde-auth-nextjs": "^2.3.11",
    "@mantine/carousel": "^7.12.2",
    "@mantine/core": "^7.12.2",
    "@mantine/dates": "^7.12.2",
    "@mantine/dropzone": "^7.12.2",
    "@mantine/form": "^7.12.2",
    "@mantine/hooks": "^7.12.2",
    "@mantine/modals": "^7.12.2",
    "@mantine/notifications": "^7.12.2",
    "@stripe/stripe-js": "^4.7.0",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "^0.5.1",
    "@supabase/supabase-js": "^2.45.4",
    "@tabler/icons-react": "^3.19.0",
    "dayjs": "^1.11.13",
    "dotenv": "^16.4.5",
    "embla-carousel-react": "^8.3.0",
    "framer-motion": "^11.11.0",
    "micro": "^10.0.1",
    "next": "14.2.13",
    "openai": "^4.63.0",
    "react": "^18",
    "react-dom": "^18",
    "react-markdown": "^8.0.7",
    "react-simple-typewriter": "^5.0.1",
    "stripe": "^17.1.0"
  },
  "devDependencies": {
    "@types/micro": "^10.0.0",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "postcss": "^8.4.47",
    "postcss-preset-mantine": "^1.17.0",
    "postcss-simple-vars": "^7.0.1",
    "typescript": "^5"
  }
}

================
File: postcss.config.cjs
================
module.exports = {
    plugins: {
      'postcss-preset-mantine': {},
      'postcss-simple-vars': {
        variables: {
          'mantine-breakpoint-xs': '36em',
          'mantine-breakpoint-sm': '48em',
          'mantine-breakpoint-md': '62em',
          'mantine-breakpoint-lg': '75em',
          'mantine-breakpoint-xl': '88em',
        },
      },
    },
  };

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", "app/api/auth/[...nextauth].ts"],
  "exclude": ["node_modules"]
}

================
File: vercel.json
================
{
    "crons": [{
      "path": "/api/cron/monthly-token-distribution",
      "schedule": "0 1 1 * *"
    }]
  }
