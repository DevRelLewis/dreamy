This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-13T20:57:35.790Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
app/
  admin/
    page.tsx
  api/
    auth/
      [kindeAuth]/
        route.ts
    contact/
      contact.ts
    cron/
      monthly-token-distribution/
        route.ts
    dalle/
      route.ts
    dreamy/
      route.ts
    payment-success/
      route.ts
    payment-success-1000/
      route.ts
    payment-success-1500/
      route.ts
    payment-success-500/
      route.ts
    process-query/
      route.ts
    test/
      route.ts
  auth-callback/
    page.tsx
  chat/
    page.module.css
    page.tsx
  payment-complete/
    page.tsx
  globals.css
  layout.tsx
  page.module.css
  page.tsx
components/
  auth/
    auth-provider.tsx
    authForm.tsx
    user-profile.tsx
  chat/
    ChatComponent.tsx
    page.module.css
  contactModal/
    contactModal.tsx
  disclaimer/
    disclaimermodal.module.css
    dislaimer.tsx
  StatsCard/
    StatsCard.tsx
  token system/
    TokenSystem.ts
  utils/
    tokenUtils/
      TokenUtility.ts
      types.ts
    user-utils.ts
  dreamhistorymenu.tsx
constants/
  constants.ts
supabase/
  supabaseClient.js
.gitignore
middelware.ts
middleware.ts
next.config.mjs
package.json
postcss.config.cjs
README.md
tsconfig.json
vercel.json

================================================================
Repository Files
================================================================

================
File: app/admin/page.tsx
================
'use client'

import React, { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  AppShell,
  AppShellHeader,
  AppShellNavbar,
  AppShellMain,
  Title,
  LoadingOverlay,
  Container,
  Button,
  Stack,
  Group,
  Notification,
} from '@mantine/core';
import { IconCheck } from '@tabler/icons-react';
import { createClient } from '@supabase/supabase-js';
import StatsCard from '@/components/StatsCard/StatsCard';

const AdminSettings = () => {
  const [isAdmin, setIsAdmin] = useState<boolean | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [successMessage, setSuccessMessage] = useState('');
  const [stats, setStats] = useState({
    totalUsers: 0,
    totalSubscribers: 0,
    totalSessions: 0,
    totalTokensSpent: 0,
  });
  const router = useRouter();
  
  const supabase = createClient(
    process.env.SUPABASE_URL!,
    process.env.SUPABASE_KEY!
  );

  useEffect(() => {
    const checkAdminStatus = async () => {
      try {
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        
        if (userError || !user) {
          setIsAdmin(false);
          return;
        }

        const { data, error } = await supabase
          .from('users')
          .select('is_admin')
          .eq('id', user.id)
          .single();

        if (error || !data) {
          console.error('Error fetching admin status:', error);
          setIsAdmin(false);
        } else {
          setIsAdmin(data.is_admin);
        }
      } catch (error) {
        console.error('Error checking admin status:', error);
        setIsAdmin(false);
      } finally {
        setIsLoading(false);
      }
    };

    checkAdminStatus();
  }, [supabase]);

  useEffect(() => {
    if (!isLoading && !isAdmin) {
      router.push('/');
    } else if (isAdmin) {
      fetchStats();
    }
  }, [isAdmin, isLoading, router]);

  const fetchStats = async () => {
    try {
      // Fetch total users
      const { count: totalUsers } = await supabase
        .from('users')
        .select('*', { count: 'exact', head: true });

      // Fetch total subscribers
      const { count: totalSubscribers } = await supabase
        .from('users')
        .select('*', { count: 'exact', head: true })
        .eq('is_subscribed', true);

      // Fetch total sessions
      const { count: totalSessions } = await supabase
        .from('dream_sessions')
        .select('*', { count: 'exact', head: true });

      // Fetch total tokens spent
      const { data: users, error } = await supabase
        .from('users')
        .select('token_transactions');

      if (error) {
        throw error;
      }

      let totalTokensSpent = 0;
      users.forEach(user => {
        if (user.token_transactions && Array.isArray(user.token_transactions)) {
          user.token_transactions.forEach((transaction: { amount: number }) => {
            totalTokensSpent += Math.abs(transaction.amount);
          });
        }
      });

      setStats({
        totalUsers: totalUsers || 0,
        totalSubscribers: totalSubscribers || 0,
        totalSessions: totalSessions || 0,
        totalTokensSpent,
      });
    } catch (error) {
      console.error('Error fetching stats:', error);
    }
  };

  if (isLoading) {
    return <LoadingOverlay visible={true} />;
  }

  if (!isAdmin) {
    return null; // Non-admin users are redirected
  }

  return (
    <AppShell padding="md">
      <AppShellHeader p="xs">
        <Title order={3}>Admin Dashboard</Title>
      </AppShellHeader>

      <AppShellNavbar p="xs" zIndex={-1} style={{paddingTop: 75, background: 'blue', color: 'white'}}>
        <Button variant="subtle" fullWidth mt="md">
          Dashboard
        </Button>
        <Button variant="subtle" fullWidth mt="sm">
          User Management
        </Button>
        <Button variant="subtle" fullWidth mt="sm">
          Reports
        </Button>
      </AppShellNavbar>

      <AppShellMain>
        <Container>
          <Stack>
            <Title order={4}>Key Metrics</Title>
            <Group>
              <StatsCard title="Total Users" stat={stats.totalUsers} />
              <StatsCard title="Total Subscribers" stat={stats.totalSubscribers} />
              <StatsCard title="Total Sessions" stat={stats.totalSessions} />
              <StatsCard title="Total Tokens Spent" stat={stats.totalTokensSpent} />
            </Group>

            {successMessage && (
              <Notification
                icon={<IconCheck size={18} />}
                color="teal"
                title="Success"
                onClose={() => setSuccessMessage('')}
              >
                {successMessage}
              </Notification>
            )}
          </Stack>
        </Container>
      </AppShellMain>
    </AppShell>
  );
};

export default AdminSettings;

================
File: app/api/auth/[kindeAuth]/route.ts
================
import {handleAuth} from "@kinde-oss/kinde-auth-nextjs/server";
export const GET = handleAuth();

================
File: app/api/contact/contact.ts
================
import type { NextApiRequest, NextApiResponse } from 'next';
import nodemailer from 'nodemailer';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  try {
    const { subject, message } = req.body;

    // Configure your email transport here
    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASSWORD,
      },
    });

    await transporter.sendMail({
      from: process.env.EMAIL_USER,
      to: process.env.CONTACT_EMAIL,
      subject: `Dream-San Contact: ${subject}`,
      text: message,
    });

    return res.status(200).json({ message: 'Message sent successfully' });
  } catch (error) {
    console.error('Contact form error:', error);
    return res.status(500).json({ message: 'Failed to send message' });
  }
}

================
File: app/api/cron/monthly-token-distribution/route.ts
================
// app/api/cron/monthly-token-distribution/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_KEY!
);

export async function GET(req: NextRequest) {
  // Verify the request is coming from the cron job
  const authHeader = req.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    // Fetch all subscribed users
    const { data: subscribedUsers, error: fetchError } = await supabase
      .from('users')
      .select('id, token_balance')
      .eq('is_subscribed', true);

    if (fetchError) {
      throw new Error(`Failed to fetch subscribed users: ${fetchError.message}`);
    }

    // update token balance for each subscribed user
    const updatePromises = subscribedUsers.map(user => 
      supabase
        .from('users')
        .update({ token_balance: user.token_balance + 1500 })
        .eq('id', user.id)
    );

    await Promise.all(updatePromises);

    console.log(`Updated token balance for ${subscribedUsers.length} users`);

    return NextResponse.json({
      message: `Successfully updated token balance for ${subscribedUsers.length} users`,
      success: true
    });
  } catch (error) {
    console.error('Error in monthly token distribution:', error);
    return NextResponse.json(
      { error: 'Failed to process monthly token distribution' },
      { status: 500 }
    );
  }
}

================
File: app/api/dalle/route.ts
================
// dalle.ts
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';

// const openai = new OpenAI({
//   apiKey: process.env.OPENAI_API_KEY,
// });

// const supabase = createClient(
//   process.env.SUPABASE_URL!,
//   process.env.SUPABASE_KEY!
// );

// export async function POST(req: NextRequest) {
//   try {
//     // Validate environment variables
//     if (!process.env.OPENAI_API_KEY || !process.env.SUPABASE_URL || !process.env.SUPABASE_KEY) {
//       throw new Error('Missing required environment variables');
//     }

//     const { prompt, userId } = await req.json();

//     if (!prompt || !userId) {
//       return NextResponse.json({ error: 'Prompt and userId are required' }, { status: 400 });
//     }

//     // Verify user exists before proceeding
//     const { data: user, error: userError } = await supabase
//       .from('users')
//       .select('id')
//       .eq('id', userId)
//       .single();

//     if (userError || !user) {
//       console.error('User not found:', userError);
//       return NextResponse.json({ error: 'User not found' }, { status: 404 });
//     }

//     const image = await openai.images.generate({
//       model: "dall-e-3",
//       prompt: prompt,
//       n: 1,
//       size: "1024x1024",
//       response_format: "b64_json"
//     });

//     const base64Image = image.data[0].b64_json;

//     if (!base64Image) {
//       throw new Error('Failed to generate image: No base64 data received');
//     }

//     const imageBuffer = Buffer.from(base64Image, 'base64');
//     const filename = `dream_image_${Date.now()}.png`;
//     const filePath = `${userId}/${filename}`;

//     const { error: uploadError } = await supabase.storage
//       .from('dream-images')
//       .upload(filePath, imageBuffer, {
//         contentType: 'image/png',
//         upsert: false
//       });

//     if (uploadError) {
//       throw new Error(`Failed to upload image: ${uploadError.message}`);
//     }

//     const { data: publicUrlData } = supabase.storage
//       .from('dream-images')
//       .getPublicUrl(filePath);

//     return NextResponse.json({ imageUrl: publicUrlData.publicUrl });
//   } catch (error) {
//     console.error('Error:', error);
//     return NextResponse.json({ 
//       error: error instanceof Error ? error.message : 'Failed to generate and save image',
//       details: error instanceof Error ? error.stack : undefined
//     }, { status: 500 });
//   }
// }

================
File: app/api/dreamy/route.ts
================
// dreamy.ts
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_KEY!
);

const ASSISTANT_ID = 'asst_xpIJVdaLp5VrggV7WwOQQFGk';

export async function POST(req: NextRequest) {
  try {
    // Validate environment variables
    if (!process.env.OPENAI_API_KEY || !process.env.SUPABASE_URL || !process.env.SUPABASE_KEY) {
      throw new Error('Missing required environment variables');
    }

    const { prompt, userId, sessionId } = await req.json();

    if (!prompt || !userId) {
      return NextResponse.json({ error: 'Prompt and userId are required' }, { status: 400 });
    }

    // Verify user exists before proceeding
    const { data: user, error: userError } = await supabase
      .from('users')
      .select('id')
      .eq('id', userId)
      .single();

    if (userError || !user) {
      console.error('User not found:', userError);
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    const thread = await openai.beta.threads.create();

    await openai.beta.threads.messages.create(thread.id, {
      role: "user",
      content: prompt
    });

    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: ASSISTANT_ID
    });

    let runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
    let attempts = 0;
    const maxAttempts = 60; // Increased to 60 seconds
    const pollInterval = 2000; // Poll every 2 seconds instead of 1

    while (runStatus.status !== 'completed' && attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, pollInterval));
      runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
      attempts++;

      // Check for failed or cancelled status
      if (runStatus.status === 'failed' || runStatus.status === 'cancelled') {
        throw new Error(`Assistant run ${runStatus.status}: ${runStatus.last_error?.message || 'Unknown error'}`);
      }
    }

    if (attempts >= maxAttempts) {
      throw new Error('Assistant response timeout');
    }

    const messages = await openai.beta.threads.messages.list(thread.id);
    const lastAssistantMessage = messages.data
      .filter(message => message.role === 'assistant')
      .pop();

    if (!lastAssistantMessage) {
      throw new Error('No response from assistant');
    }

    const responseContent = lastAssistantMessage.content.reduce((acc, content) => {
      if (content.type === 'text') {
        return acc + content.text.value;
      }
      return acc;
    }, '');

    // Session handling code...
    let newSessionId = sessionId;

    if (sessionId) {
      const { data: existingSession, error: fetchError } = await supabase
        .from('dream_sessions')
        .select('dream_text, interpretation')
        .eq('id', sessionId)
        .single();

      if (fetchError) {
        throw new Error(`Failed to fetch session: ${fetchError.message}`);
      }

      const { error: updateError } = await supabase
        .from('dream_sessions')
        .update({
          dream_text: `${existingSession.dream_text}\n\n${prompt}`,
          interpretation: `${existingSession.interpretation}\n\n${responseContent}`
        })
        .eq('id', sessionId);

      if (updateError) {
        throw new Error(`Failed to update session: ${updateError.message}`);
      }
    } else {
      const { data: insertedSession, error: insertError } = await supabase
        .from('dream_sessions')
        .insert({
          user_id: userId,
          dream_text: prompt,
          interpretation: responseContent,
          messages: []
        })
        .select()
        .single();

      if (insertError) {
        throw new Error(`Failed to create session: ${insertError.message}`);
      }

      newSessionId = insertedSession.id;
    }

    return NextResponse.json({ 
      reply: responseContent,
      sessionId: newSessionId
    });
  } catch (error) {
    console.error('Error:', error);
    return NextResponse.json({ 
      error: error instanceof Error ? error.message : 'Failed to get assistant response',
      details: error instanceof Error ? error.stack : undefined
    }, { status: 500 });
  }
}

================
File: app/api/payment-success/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { createClient } from '@supabase/supabase-js';

// const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

// const supabase = createClient(
//   process.env.SUPABASE_URL!,
//   process.env.SUPABASE_KEY!
// );

// export async function POST(req: NextRequest) {
//   const rawBody = await req.text();
//   const sig = req.headers.get('stripe-signature') as string;

//   let event: Stripe.Event;

//   try {
//     event = stripe.webhooks.constructEvent(
//       rawBody,
//       sig,
//       process.env.STRIPE_WEBHOOK_SECRET!
//     );
//   } catch (err) {
//     console.error('Webhook signature verification failed:', err instanceof Error ? err.message : 'Unknown Error');
//     return NextResponse.json(
//       { error: `Webhook Error: ${err instanceof Error ? err.message : 'Unknown Error'}` },
//       { status: 400 }
//     );
//   }

//   console.log('Received event:', event.type);

//   if (event.type === 'checkout.session.completed') {
//     const session = event.data.object as Stripe.Checkout.Session;
    
//     const userEmail = session.customer_email || 'gregory.reeves@teachstone.com';

//     console.log('Processing completed checkout for:', userEmail);

//     try {
//       // Fetch the user from Supabase
//       const { data: userData, error: userError } = await supabase
//         .from('users')
//         .select('id, token_balance')
//         .eq('email', userEmail)
//         .single();

//       if (userError || !userData) {
//         console.error('User not found:', userEmail);
//         throw new Error('User not found');
//       }

//       // Update the user's subscription status and token balance
//       const newBalance = userData.token_balance + 1500;
//       const { error: updateError } = await supabase
//         .from('users')
//         .update({ 
//           is_subscribed: true,
//           token_balance: newBalance
//         })
//         .eq('id', userData.id);

//       if (updateError) {
//         console.error('Failed to update user data:', updateError);
//         throw new Error('Failed to update user data');
//       }

//       console.log('Successfully updated user data for:', userEmail);
//       return NextResponse.json({ received: true, processed: true });
//     } catch (error) {
//       console.error('Error processing webhook:', error);
//       return NextResponse.json({ error: 'Failed to process payment' }, { status: 500 });
//     }
//   } else {
//     console.log('Unhandled event type:', event.type);
//     return NextResponse.json({ received: true, processed: false });
//   }
// }

================
File: app/api/payment-success-1000/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { createClient } from '@supabase/supabase-js';

// const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

// const supabase = createClient(
//   process.env.SUPABASE_URL!,
//   process.env.SUPABASE_KEY!
// );

// export async function POST(req: NextRequest) {
//   const rawBody = await req.text();
//   const sig = req.headers.get('stripe-signature') as string;

//   let event: Stripe.Event;

//   try {
//     event = stripe.webhooks.constructEvent(
//       rawBody,
//       sig,
//       process.env.STRIPE_WEBHOOK_SECRET!
//     );
//   } catch (err) {
//     console.error('Webhook signature verification failed:', err instanceof Error ? err.message : 'Unknown Error');
//     return NextResponse.json(
//       { error: `Webhook Error: ${err instanceof Error ? err.message : 'Unknown Error'}` },
//       { status: 400 }
//     );
//   }

//   console.log('Received event:', event.type);

//   if (event.type === 'checkout.session.completed') {
//     const session = event.data.object as Stripe.Checkout.Session;
    
//     // For testing, you might need to retrieve the customer email differently
//     // as the test event might not include a customer email
//     const userEmail = session.customer_email || 'gregory.reeves@teachstone.com';

//     console.log('Processing completed checkout for:', userEmail);

//     try {
//       // Fetch the user from Supabase
//       const { data: userData, error: userError } = await supabase
//         .from('users')
//         .select('id, token_balance')
//         .eq('email', userEmail)
//         .single();

//       if (userError || !userData) {
//         console.error('User not found:', userEmail);
//         throw new Error('User not found');
//       }

//       // Update the user's subscription status and token balance
//       const newBalance = userData.token_balance + 1000;
//       const { error: updateError } = await supabase
//         .from('users')
//         .update({ 
//           token_balance: newBalance
//         })
//         .eq('id', userData.id);

//       if (updateError) {
//         console.error('Failed to update user data:', updateError);
//         throw new Error('Failed to update user data');
//       }

//       console.log('Successfully updated user data for:', userEmail);
//       return NextResponse.json({ received: true, processed: true });
//     } catch (error) {
//       console.error('Error processing webhook:', error);
//       return NextResponse.json({ error: 'Failed to process payment' }, { status: 500 });
//     }
//   } else {
//     console.log('Unhandled event type:', event.type);
//     return NextResponse.json({ received: true, processed: false });
//   }
// }

================
File: app/api/payment-success-1500/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { createClient } from '@supabase/supabase-js';

// const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

// const supabase = createClient(
//   process.env.SUPABASE_URL!,
//   process.env.SUPABASE_KEY!
// );

// export async function POST(req: NextRequest) {
//   const rawBody = await req.text();
//   const sig = req.headers.get('stripe-signature') as string;

//   let event: Stripe.Event;

//   try {
//     event = stripe.webhooks.constructEvent(
//       rawBody,
//       sig,
//       process.env.STRIPE_WEBHOOK_SECRET!
//     );
//   } catch (err) {
//     console.error('Webhook signature verification failed:', err instanceof Error ? err.message : 'Unknown Error');
//     return NextResponse.json(
//       { error: `Webhook Error: ${err instanceof Error ? err.message : 'Unknown Error'}` },
//       { status: 400 }
//     );
//   }

//   console.log('Received event:', event.type);

//   if (event.type === 'checkout.session.completed') {
//     const session = event.data.object as Stripe.Checkout.Session;
    
//     // For testing, you might need to retrieve the customer email differently
//     // as the test event might not include a customer email
//     const userEmail = session.customer_email || 'gregory.reeves@teachstone.com';

//     console.log('Processing completed checkout for:', userEmail);

//     try {
//       // Fetch the user from Supabase
//       const { data: userData, error: userError } = await supabase
//         .from('users')
//         .select('id, token_balance')
//         .eq('email', userEmail)
//         .single();

//       if (userError || !userData) {
//         console.error('User not found:', userEmail);
//         throw new Error('User not found');
//       }

//       // Update the user's subscription status and token balance
//       const newBalance = userData.token_balance + 1500;
//       const { error: updateError } = await supabase
//         .from('users')
//         .update({ 
//           token_balance: newBalance
//         })
//         .eq('id', userData.id);

//       if (updateError) {
//         console.error('Failed to update user data:', updateError);
//         throw new Error('Failed to update user data');
//       }

//       console.log('Successfully updated user data for:', userEmail);
//       return NextResponse.json({ received: true, processed: true });
//     } catch (error) {
//       console.error('Error processing webhook:', error);
//       return NextResponse.json({ error: 'Failed to process payment' }, { status: 500 });
//     }
//   } else {
//     console.log('Unhandled event type:', event.type);
//     return NextResponse.json({ received: true, processed: false });
//   }
// }

================
File: app/api/payment-success-500/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { createClient } from '@supabase/supabase-js';

// const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

// const supabase = createClient(
//   process.env.SUPABASE_URL!,
//   process.env.SUPABASE_KEY!
// );

// export async function POST(req: NextRequest) {
//   const rawBody = await req.text();
//   const sig = req.headers.get('stripe-signature') as string;

//   let event: Stripe.Event;

//   try {
//     event = stripe.webhooks.constructEvent(
//       rawBody,
//       sig,
//       process.env.STRIPE_WEBHOOK_SECRET!
//     );
//   } catch (err) {
//     console.error('Webhook signature verification failed:', err instanceof Error ? err.message : 'Unknown Error');
//     return NextResponse.json(
//       { error: `Webhook Error: ${err instanceof Error ? err.message : 'Unknown Error'}` },
//       { status: 400 }
//     );
//   }

//   console.log('Received event:', event.type);

//   if (event.type === 'checkout.session.completed') {
//     const session = event.data.object as Stripe.Checkout.Session;
    
//     // For testing, you might need to retrieve the customer email differently
//     // as the test event might not include a customer email
//     const userEmail = session.customer_email || 'gregory.reeves@teachstone.com';

//     console.log('Processing completed checkout for:', userEmail);

//     try {
//       // Fetch the user from Supabase
//       const { data: userData, error: userError } = await supabase
//         .from('users')
//         .select('id, token_balance')
//         .eq('email', userEmail)
//         .single();

//       if (userError || !userData) {
//         console.error('User not found:', userEmail);
//         throw new Error('User not found');
//       }

//       // Update the user's subscription status and token balance
//       const newBalance = userData.token_balance + 500;
//       const { error: updateError } = await supabase
//         .from('users')
//         .update({ 
//           token_balance: newBalance
//         })
//         .eq('id', userData.id);

//       if (updateError) {
//         console.error('Failed to update user data:', updateError);
//         throw new Error('Failed to update user data');
//       }

//       console.log('Successfully updated user data for:', userEmail);
//       return NextResponse.json({ received: true, processed: true });
//     } catch (error) {
//       console.error('Error processing webhook:', error);
//       return NextResponse.json({ error: 'Failed to process payment' }, { status: 500 });
//     }
//   } else {
//     console.log('Unhandled event type:', event.type);
//     return NextResponse.json({ received: true, processed: false });
//   }
// }

================
File: app/api/process-query/route.ts
================
// app/api/process-query/route.ts
import { NextResponse } from 'next/server';
import { processTokenTransaction } from '@/components/token system/TokenSystem';
import { hasEnoughTokens } from '@/components/utils/tokenUtils/TokenUtility';
import { createClient } from '@supabase/supabase-js';
import { User } from '@/components/utils/tokenUtils/types';

// Initialize Supabase client
const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

export async function POST(request: Request) {
  const { userId, query } = await request.json();

  // Fetch user from database
  const { data: user, error } = await supabase
    .from('users')
    .select('id, token_balance')
    .eq('id', userId)
    .single();

  if (error || !user) {
    return NextResponse.json(false, { status: 404 });
  }

  if (!hasEnoughTokens(user as User, query)) {
    return NextResponse.json(false, { status: 402 });
  }

  const success = await processTokenTransaction(userId, query);

  return NextResponse.json(success);
}

================
File: app/api/test/route.ts
================
import { NextResponse } from 'next/server';

   export const runtime = 'edge';

   export async function GET() {
     return NextResponse.json({ message: 'Test route is working' });
   }

================
File: app/auth-callback/page.tsx
================
'use client'

import { useEffect } from 'react'
import { useKindeBrowserClient } from '@kinde-oss/kinde-auth-nextjs'
import { useRouter } from 'next/navigation'
import { supabase } from '@/supabase/supabaseClient'

export default function AuthCallback() {
  const { isLoading, isAuthenticated, user } = useKindeBrowserClient()
  const router = useRouter()

  useEffect(() => {
    const syncUserWithDatabase = async () => {
      if (!isLoading && isAuthenticated && user) {
        try {
          // Check if user exists in Supabase
          const { data: existingUser, error: userError } = await supabase
            .from('users')
            .select('*')
            .eq('email', user.email)
            .single()

          if (userError && userError.code !== 'PGRST116') {
            console.error('Error checking for existing user:', userError)
          }

          // If user exists, update their Kinde ID if needed
          if (existingUser) {
            if (!existingUser.kinde_user_id) {
              const { error: updateError } = await supabase
                .from('users')
                .update({ 
                  kinde_user_id: user.id,
                  first_name: user.given_name || existingUser.first_name,
                  last_name: user.family_name || existingUser.last_name,
                  avatar_url: user.picture || existingUser.avatar_url
                })
                .eq('id', existingUser.id)

              if (updateError) {
                console.error('Error updating user:', updateError)
              }
            }
          } else {
            // Create new user
            const { error: insertError } = await supabase
            .from('users')
            .insert({
                email: user.email,
                first_name: user.given_name || '',
                last_name: user.family_name || '',
                kinde_user_id: user.id,
                avatar_url: '', // Set this to empty string instead of user.picture
                token_balance: 250,
                tokens_spent: 0,
                is_subscribed: false,
                username: null // If you made this nullable
            })

            if (insertError) {
              console.error('Error creating user:', insertError)
            }
          }

          // Redirect to the chat page
          router.push('/chat')
        } catch (error) {
          console.error('Error in auth callback:', error)
          router.push('/')
        }
      } else if (!isLoading && !isAuthenticated) {
        router.push('/')
      }
    }

    syncUserWithDatabase()
  }, [isLoading, isAuthenticated, user, router])

  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="flex flex-col items-center space-y-4">
        <h1 className="text-2xl font-bold">Setting up your account...</h1>
        <div className="h-8 w-8 animate-spin rounded-full border-b-2 border-t-2 border-purple-500"></div>
      </div>
    </div>
  )
}

================
File: app/chat/page.module.css
================
.scrollbar {

    &,
    &:hover {
      background-color: transparent;
    }

    padding-left: 5px;
    border-radius: 25px;
  
    &[data-orientation='vertical'] .thumb {
      background-color: rgba(179, 229, 252, 0.8);
    }
  }
  
  .corner {
    background-color: transparent;
    opacity: 0;
  }

================
File: app/chat/page.tsx
================
import dynamic from 'next/dynamic'

const ClientChat = dynamic(() => import('../../components/chat/ChatComponent'), { ssr: false })

export default function ChatPage() {
  return <ClientChat />
}

================
File: app/payment-complete/page.tsx
================
'use client'

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';

export default function PaymentComplete() {
  const router = useRouter();

  useEffect(() => {
    // Redirect to the main app page after a short delay
    const timer = setTimeout(() => {
      router.push('/chat'); 
    }, 5000);

    return () => clearTimeout(timer);
  }, [router]);

  return (
    <div>
      <h1>Payment Successful!</h1>
      <p>Your subscription has been activated and tokens have been added to your account.</p>
      <p>You will be redirected to the main app in a few seconds...</p>
    </div>
  );
}

================
File: app/globals.css
================
:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}

================
File: app/layout.tsx
================
import '@mantine/core/styles.css';
// Add this import for notifications
import '@mantine/notifications/styles.css';
import { ColorSchemeScript, MantineProvider } from '@mantine/core';
// Add this import for notifications
import { Notifications } from '@mantine/notifications';
import { Merriweather } from 'next/font/google';
// Import the AuthProvider
import { AuthProvider } from '../components/auth/auth-provider';

const merriweather = Merriweather({ weight: '400', subsets: ['latin'] });

export const metadata = {
  title: 'Dream-San',
  description: 'Specialized AI for Dream Interpretation.',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <head>
        <ColorSchemeScript />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
      </head>
      <body className={merriweather.className}>
        <MantineProvider
          theme={{
            fontSizes: {
              xs: '0.75rem',
              sm: '0.875rem',
              md: '1rem',
              lg: '1.125rem',
              xl: '1.25rem',
            },
            breakpoints: {
              xs: '30em',
              sm: '48em',
              md: '64em',
              lg: '74em',
              xl: '90em',
            },
          }}
        >
          {/* Add the Notifications component */}
          <Notifications />
          {/* Wrap children with AuthProvider */}
          <AuthProvider>
            {children}
          </AuthProvider>
        </MantineProvider>
      </body>
    </html>
  );
}

================
File: app/page.module.css
================
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition: background 0.2s, color 0.2s, border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 180px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}

================
File: app/page.tsx
================
import Image from "next/image";
import styles from "./page.module.css";
import AuthForm from "@/components/auth/authForm";

export default function Home() {
  return (
    <>
      <AuthForm/>
    </>
  );
}

================
File: components/auth/auth-provider.tsx
================
'use client'

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react'
import { useKindeBrowserClient } from '@kinde-oss/kinde-auth-nextjs'
import { syncUserWithDatabase, getCurrentUserData } from '../utils/user-utils'

interface UserData {
  id: string
  email: string
  first_name?: string
  last_name?: string
  token_balance: number
  tokens_spent: number
  is_subscribed: boolean
  kinde_user_id?: string
  avatar_url?: string
}

interface AuthContextType {
  user: UserData | null
  loading: boolean
  updateUser: () => Promise<UserData | null>
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  updateUser: async () => null
})

export const useAuth = () => useContext(AuthContext)

interface AuthProviderProps {
  children: ReactNode
}

export function AuthProvider({ children }: AuthProviderProps) {
  const { user: kindeUser, isLoading, isAuthenticated } = useKindeBrowserClient()
  const [user, setUser] = useState<UserData | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const fetchUserData = async () => {
      try {
        if (!isLoading) {
          if (isAuthenticated && kindeUser) {
            // First ensure the user exists in the database
            await syncUserWithDatabase(kindeUser)
            // Then get the full user data
            const userData = await getCurrentUserData(kindeUser)
            setUser(userData)
          } else {
            setUser(null)
          }
          setLoading(false)
        }
      } catch (error) {
        console.error('Error fetching user data:', error)
        setLoading(false)
      }
    }

    fetchUserData()
  }, [isLoading, isAuthenticated, kindeUser])

  const updateUser = async () => {
    if (kindeUser) {
      const updatedUser = await getCurrentUserData(kindeUser)
      setUser(updatedUser)
      return updatedUser
    }
    return null
  }

  return (
    <AuthContext.Provider value={{ user, loading, updateUser }}>
      {children}
    </AuthContext.Provider>
  )
}

================
File: components/auth/authForm.tsx
================
'use client'
import React, { useState } from 'react';
import {
  Button,
  Box,
  Paper,
  Text,
  Flex,
  Alert,
  Center,
  Container,
  useMantineTheme,
  Image,
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { useRouter } from 'next/navigation';
import { supabase } from '../../supabase/supabaseClient';
import { useMediaQuery } from '@mantine/hooks';
import dreamsanbg from '../../app/public/dream-san-bg-t-2.png'
import google from '../../app/public/google.png'
import apple from "../../app/public/apple.png"
import twitter from "../../app/public/twitter.png"
import NextImage from 'next/image'
import {RegisterLink, LoginLink} from "@kinde-oss/kinde-auth-nextjs/components";


type AuthMode = 'signIn' | 'signUp';

const AuthForm: React.FC = () => {
  const [authMode, setAuthMode] = useState<AuthMode>('signIn');
  const [email, setEmail] = useState<string>('');
  const [password, setPassword] = useState<string>('');
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();
  const theme = useMantineTheme();
  const isMobileOrTablet = useMediaQuery('(max-width: 1024px)');
  const isNarrowMobile = useMediaQuery('(max-width: 320px)');

  return (
    <Center 
      h="100vh" 
      p={isMobileOrTablet ? 'xs' : 'lg'} 
      style={{
        overflow: 'hidden',
        background: 'linear-gradient(135deg, #ffd54f 0%, #ff8a65 25%, #7e57c2 50%, #5c6bc0 75%, #42a5f5 100%)'
      }}
    >
      {!isMobileOrTablet && (
        <Box
          style={{
            marginLeft: -20,
            width: '50vw', 
            height: '100vh', 
            display: 'flex',
            justifyContent: 'flex-start', 
            alignItems: 'flex-start',
          }}
        >
          <Image
            component={NextImage}
            h='100vh'
            width={1200}
            src={dreamsanbg}
            alt="dreamsanbg"
            style={{
              margin: 0,
              padding: 0,
              display: 'block', 
            }}
          />
        </Box>
      )}
      <Container 
        size={isMobileOrTablet ? '100%' : 'xs'} 
        p={0}
        style={{
          width: isMobileOrTablet ? '100%' : '50%',
        }}
      >
        <Paper radius="md" p={isMobileOrTablet ? 'sm' : 'xl'} bg="rgba(179, 229, 252, 0.8)">
          <Text size={isMobileOrTablet ? (isNarrowMobile ? 'sm' : 'md') : '35px'} fw={500} ta="center" mb="md">
            {authMode === 'signIn' ? 'Welcome to Dream-San' : 'Create an Account'}
          </Text>
          <Text size={isMobileOrTablet ? (isNarrowMobile ? 'xs' : 'sm') : '25px'} fw={500} ta="center" mb="md">Your AI Dream Interpreter</Text>

          {error && (
            <Alert title="Error" color="red" mb="md">
              {error}
            </Alert>
          )}

          <Flex direction="column" align="center" gap="md">
            <LoginLink 
              className="rounded-md px-4 py-2"
              style={{
                backgroundColor: '#7e57c2', // This purple matches one of the gradient colors
                color: 'white',
                borderRadius: '8px',
                padding: '8px 16px',
                textDecoration: 'none',
                width: '200px',
                textAlign: 'center'
              }}
              postLoginRedirectURL="/chat">
              Sign in
            </LoginLink>
            <RegisterLink 
              className="rounded-md px-4 py-2"
              style={{
                backgroundColor: '#7e57c2', // This purple matches one of the gradient colors
                color: 'white',
                borderRadius: '8px',
                padding: '8px 16px',
                textDecoration: 'none',
                width: '200px',
                textAlign: 'center'
              }}
              postLoginRedirectURL="/chat">
              Sign up
            </RegisterLink>
          </Flex>
        </Paper>
      </Container>
    </Center>
  );
};

export default AuthForm;

================
File: components/auth/user-profile.tsx
================
'use client'

import React from 'react'
import { Avatar, Menu, Text, Button, Flex, Container, Stack } from '@mantine/core'
import { LogoutLink } from '@kinde-oss/kinde-auth-nextjs/components'
import { useRouter } from 'next/navigation'

interface UserProfileProps {
  userData: {
    id: string
    first_name?: string
    last_name?: string
    email: string
    token_balance: number
    is_subscribed: boolean
    avatar_url?: string
  } | null
  onOpenSubscriptionModal: () => void
  onOpenTopUpModal: () => void
}

const UserProfile: React.FC<UserProfileProps> = ({ 
  userData, 
  onOpenSubscriptionModal, 
  onOpenTopUpModal 
}) => {
  const router = useRouter()

  // Get initial for avatar display
  const getInitial = () => {
    if (!userData) return 'U'
    
    if (userData.first_name) {
      return userData.first_name[0].toUpperCase()
    }
    
    if (userData.email) {
      return userData.email[0].toUpperCase()
    }
    
    return 'U'
  }

  return (
    <Menu>
      <Menu.Target>
      <Avatar
  color="violet"
  radius="xl"
  style={{
    transition: "all 0.2s ease-in-out",
    cursor: "pointer",
    border: "2.5px solid rgba(255, 255, 255, 0.2)",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  }}
>
  <Text 
    size="25px" 
    style={{ 
      display: "flex", 
      justifyContent: "center", 
      alignItems: "center",
      width: "100%",
      height: "100%",
      margin: 0
    }}
  >
    {getInitial()}
  </Text>
</Avatar>
      </Menu.Target>
      
      <Menu.Dropdown>
        <Menu.Label>
          <Text size="xl">
            User: {userData?.first_name || 'User'} {userData?.last_name || ''}
          </Text>
        </Menu.Label>
        
        <Menu.Label>
          <Flex direction="row" align="center" gap="10px">
            <Text size="xl">Subscribed: </Text>
            <Text
              size="xl"
              span
              c={userData?.is_subscribed ? "green" : "red"}
              fw={600}
            >
              {userData?.is_subscribed ? "Yes" : "No"}
            </Text>
          </Flex>
        </Menu.Label>
        
        <Menu.Item onClick={onOpenSubscriptionModal}>
          <Text size="xl">Manage Subscription</Text>
        </Menu.Item>
        
        <Menu.Item>
          <Stack align="center">
            <Container
              onClick={onOpenTopUpModal}
              style={{
                backgroundColor: "rgba(179, 229, 252, 0.8)",
                borderRadius: "8px",
                padding: "10px 20px",
                cursor: "pointer",
                transition: "background-color 0.3s ease",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                width: "100%",
              }}
            >
              <Text
                size="25px"
                fw={500}
                span
                style={{ color: "#2c2c2c" }}
              >
                Top Up
              </Text>
            </Container>
          </Stack>
        </Menu.Item>
        
        <Menu.Item>
          <LogoutLink
            className="rounded-md px-4 py-2"
            style={{
              backgroundColor: '#7e57c2',
              color: 'white',
              borderRadius: '8px',
              padding: '8px 16px',
              textDecoration: 'none',
              width: '100%',
              textAlign: 'center',
              display: 'block'
            }}
            postLogoutRedirectURL="/"
          >
            Logout
          </LogoutLink>
        </Menu.Item>
      </Menu.Dropdown>
    </Menu>
  )
}

export default UserProfile

================
File: components/chat/ChatComponent.tsx
================
"use client";

import React, { useState, useEffect, useRef } from "react";
import Markdown from "react-markdown";
import DisclaimerModal from "../../components/disclaimer/dislaimer";
import {
  Container,
  Box,
  Textarea,
  Button,
  Paper,
  Text,
  ScrollArea,
  Group,
  Loader,
  MantineProvider,
  AppShell,
  Avatar,
  createTheme,
  Menu,
  Stack,
  Modal,
  Card,
  Image,
  Burger,
  Flex,
  Center
} from "@mantine/core";
import { IconSend, IconMessageCircle, IconMenu2 } from "@tabler/icons-react";
import { supabase } from "../../supabase/supabaseClient";
import { Notifications, notifications } from "@mantine/notifications";
import dreamsanlogo from "../../app/public/dream-san-logo.png";
import NextImage from "next/image";
import { motion, AnimatePresence } from "framer-motion";
import { Lobster } from "next/font/google";
import { useMediaQuery, useDisclosure } from "@mantine/hooks";
import { processTokenTransaction } from "../../components/token system/TokenSystem";
import {
  hasEnoughTokens,
  estimateTokenCost,
} from "../../components/utils/tokenUtils/TokenUtility";
import classes from "./page.module.css";
import { LogoutLink } from "@kinde-oss/kinde-auth-nextjs";
import ContactModal from '../../components/contactModal/contactModal';
import { useAuth } from "../auth/auth-provider";

const lobster = Lobster({ weight: "400", subsets: ["latin"] });

type Message = {
  id: string;
  content: string;
  user_id: string;
  created_at: string;
  user: {
    id: string;
    email: string;
  };
  imageUrl?: string;
};

type DreamSession = {
  id: string;
  dream_text: string;
  created_at: string;
  image_url: string;
};

const theme = createTheme({
  primaryColor: "blue",
  fontFamily: "Segoe UI, sans-serif",
  white: "#ffffff",
  black: "#202124",
  components: {
    Button: {
      styles: (theme: any) => ({
        root: {
          borderRadius: theme.radius.md,
          padding: `${theme.spacing.xs} ${theme.spacing.md}`,
          backgroundColor: "#8da0cb",
          color: theme.white,
          transition: "background-color 0.3s ease, box-shadow 0.3s ease",

          "&:hover": {
            backgroundColor: "#7a8bbd",
            boxShadow: theme.shadows.md,
          },

          "&:disabled": {
            backgroundColor: "#a1b1d6",
            color: "#e0e0e0",
          },
        },
      }),
    },
    TextInput: {
      styles: (theme: any) => ({
        root: { flex: 2 },
        input: {
          borderRadius: theme.radius.md,
          backgroundColor: "rgba(255, 255, 255, 0.5)",
          color: theme.black,
          "&::placeholder": {
            color: "rgba(0, 0, 0, 0.5)",
          },
          "&:focus": {
            borderColor: theme.colors.blue[6],
          },
        },
      }),
    },
  },
});

const Chat: React.FC = () => {
  // Get user from auth provider
  const { user, loading: authLoading, updateUser } = useAuth();
  
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState<string>("");
  const [sending, setSending] = useState<boolean>(false);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);
  const scrollRef = useRef<HTMLDivElement>(null);
  const [isSubscriptionModalOpen, setIsSubscriptionModalOpen] = useState(false);
  const [contactModalOpened, setContactModalOpened] = useState(false);
  const [isTopUpModalOpen, setIsTopUpModalOpen] = useState(false);
  const [isSubscriptionActive, setIsSubscriptionActive] = useState<boolean>(false);
  const [isToppedUp, setIsToppedUp] = useState<boolean>(false);
  const [selectedTopUpAmount, setSelectedTopUpAmount] = useState<number | null>(null);
  const [confirmationModalOpen, setConfirmationModalOpen] = useState(false);
  const [selectedAmount, setSelectedAmount] = useState<number | null>(null);
  const isMobile = useMediaQuery("(max-width: 768px)");
  const [isNavbarExpanded, setIsNavbarExpanded] = useState(false);
  const [opened, { toggle }] = useDisclosure();
  const [mobileOpened, { toggle: toggleMobile }] = useDisclosure();
  const [desktopOpened, { toggle: toggleDesktop }] = useDisclosure(true);
  const isDesktop = useMediaQuery("(min-width: 768px)");
  const [dreamHistory, setDreamHistory] = useState<DreamSession[]>([]);
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isFirstMessage, setIsFirstMessage] = useState(true);
  const isTablet = useMediaQuery("(max-width: 1024px) and (max-height: 790px)");
  const [isDisclaimerOpen, setIsDisclaimerOpen] = useState(true);

  const truncateTitle = (title: string) => {
    const words = title.split(" ");
    return words.length > 4 ? words.slice(0, 6).join(" ") + "..." : title;
  };

  const handleManageSubscription = () => {
    setIsLoading(true);
    try {
      // Redirect to the Stripe billing portal
      window.location.href =
        "https://billing.stripe.com/p/login/test_4gw29Sez273BcyQcMM";
    } catch (error) {
      console.error("Error redirecting to subscription management:", error);
      notifications.show({
        title: "Error",
        message:
          "Failed to open subscription management page. Please try again.",
        color: "red",
      });
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    const fetchDreamHistory = async () => {
      if (!user || !user.id) return;
      
      try {
        // User is already authenticated and data loaded through auth context
        setCurrentUserId(user.id);
        setIsSubscriptionActive(user.is_subscribed || false);

        // Fetch dream history only if we have a valid user
        const { data: dreamHistoryData, error: dreamHistoryError } = await supabase
          .from('dream_sessions')
          .select('id, dream_text, created_at, image_url')
          .eq('user_id', user.id)
          .order('created_at', { ascending: false });

        if (dreamHistoryError) {
          throw dreamHistoryError;
        }

        setDreamHistory(dreamHistoryData || []);
      } catch (error) {
        console.error('Error fetching dream history:', error);
        notifications.show({
          title: 'Error',
          message: `Failed to load dream history: ${error instanceof Error ? error.message : 'Unknown error'}`,
          color: 'red',
        });
      }
    };

    if (!authLoading) {
      fetchDreamHistory();
    }
  }, [user, authLoading]);

  useEffect(() => {
    if (activeSessionId && currentUserId) {
      const updateSessionMessages = async () => {
        try {
          const { error: sessionError } = await supabase
            .from('dream_sessions')
            .update({ messages })
            .eq('id', activeSessionId)
            .eq('user_id', currentUserId);

          if (sessionError) {
            throw sessionError;
          }
        } catch (error) {
          console.error('Error updating session messages:', error);
        }
      };

      updateSessionMessages();
    }
  }, [messages, activeSessionId, currentUserId]);

  const handleDisclaimerClose = () => {
    setIsDisclaimerOpen(false);
    localStorage.setItem("hasSeenDisclaimer", "true");
  };

  const loadDreamSession = async (sessionId: string): Promise<void> => {
    setIsLoading(true);
    try {
      const { data: sessionData, error: sessionError } = await supabase
        .from("dream_sessions")
        .select("messages, image_url")
        .eq("id", sessionId)
        .single();
  
      if (sessionError) {
        throw sessionError;
      }
  
      if (sessionData && sessionData.messages) {
        const formattedMessages: Message[] = sessionData.messages;
  
        // Ensure the image URL is set for the first assistant message
        const firstAssistantMessageIndex = formattedMessages.findIndex(
          (msg) => msg.user_id === "assistant"
        );
        if (firstAssistantMessageIndex !== -1) {
          formattedMessages[firstAssistantMessageIndex].imageUrl =
            sessionData.image_url;
        }
  
        setMessages(formattedMessages);
        setActiveSessionId(sessionId);
      }
    } catch (error) {
      console.error("Error loading dream session:", error);
      notifications.show({
        title: "Error",
        message: `Failed to load dream session: ${error instanceof Error ? error.message : 'Unknown error'}`,
        color: "red",
      });
    } finally {
      setIsLoading(false);
      scrollToBottom();
    }
  };

  const scrollToBottom = () => {
    scrollRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  const handleSendMessage = async (): Promise<void> => {
    if (newMessage.trim() === "") return;
    setSending(true);
  
    if (!currentUserId || !user) {
      notifications.show({
        title: "Unauthorized",
        message: "You must be signed in to send messages.",
        color: "red",
      });
      setSending(false);
      return;
    }
  
    try {
      // Process token transaction
      const transactionSuccess = await processTokenTransaction(
        currentUserId,
        newMessage
      );
      if (!transactionSuccess) {
        throw new Error("Insufficient tokens");
      }
  
      let imageUrl: string | undefined;
  
      // Generate and save DALL-E image only if it's a new session
      if (!activeSessionId) {
        const imageResponse = await fetch("/api/dalle", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prompt: newMessage, userId: currentUserId }),
        });
  
        if (imageResponse.ok) {
          const imageData: { imageUrl: string } = await imageResponse.json();
          imageUrl = imageData.imageUrl;
        }
      }
  
      // Send message to API
      const response = await fetch("/api/dreamy", {
        method: "POST",
        headers: { 
          "Content-Type": "application/json",
          "Accept": "application/json"
        },
        body: JSON.stringify({
          prompt: newMessage,
          userId: currentUserId,
          sessionId: activeSessionId,
          imageUrl: imageUrl,
        }),
      });
  
      if (!response.ok) {
        const errorData = await response.text();
        throw new Error(`Failed to get assistant response: ${errorData}`);
      }
  
      const data: { reply: string; sessionId: string } = await response.json();
  
      // Create message objects
      const userMessage: Message = {
        id: Date.now().toString(),
        content: newMessage,
        user_id: currentUserId,
        created_at: new Date().toISOString(),
        user: { id: currentUserId, email: user.email },
      };
  
      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: data.reply,
        user_id: "assistant",
        created_at: new Date().toISOString(),
        user: { id: "assistant", email: "assistant@example.com" },
        imageUrl: imageUrl,
      };
  
      // First, get the current messages array
      const { data: currentSessionData, error: fetchError } = await supabase
        .from("dream_sessions")
        .select("messages")
        .eq("id", data.sessionId)
        .single();
  
      if (fetchError && fetchError.code !== "PGRST116") {
        throw fetchError;
      }
  
      // Prepare the new messages array
      const updatedMessages: Message[] = currentSessionData?.messages || [];
      updatedMessages.push(userMessage, assistantMessage);
  
      // Update session in Supabase
      const { error: sessionError } = await supabase
        .from("dream_sessions")
        .upsert(
          {
            id: data.sessionId,
            user_id: currentUserId,
            messages: updatedMessages,
            image_url: imageUrl,
            dream_text: newMessage
          },
          { onConflict: "id" }
        );
  
      if (sessionError) {
        throw sessionError;
      }
  
      // Update UI state
      setMessages(updatedMessages);
      setActiveSessionId(data.sessionId);
  
      // Update user's token balance and refresh user data
      await updateUser();
  
      // Clear input and update state
      setNewMessage("");
      scrollToBottom();
  
    } catch (error) {
      console.error("Error sending message:", error);
      notifications.show({
        title: "Error",
        message: `Failed to send message: ${error instanceof Error ? error.message : 'Unknown error'}`,
        color: "red",
      });
    } finally {
      setSending(false);
    }
  };

  // Show loading state while authentication is in progress
  if (authLoading) {
    return (
      <Center style={{ height: '100vh' }}>
        <Loader size="xl" color="blue" />
      </Center>
    );
  }

  return (
    <MantineProvider theme={theme}>
      <Notifications />
      <AppShell
        padding="md"
        header={{ height: 60 }}
        navbar={{
          width: 250,
          breakpoint: "sm",
          collapsed: { desktop: !desktopOpened, mobile: !mobileOpened },
        }}
        styles={(theme) => ({
          header: {
            backgroundColor: "rgba(179, 229, 252, 0.8)",
            borderBottom: "1px solid #9fa8da",
          },
          main: {
            background:
              "linear-gradient(135deg, #e0f7fa 0%, #b3e5fc 25%, #9fa8da 50%, #b39ddb 75%, #d1c4e9 100%)",
          },
        })}
      >
        <AppShell.Header>
          <Container size="xxl" h="100%" w="100%">
            <Group justify="space-between" h="100%" w="100%">
              <Group>
                <Burger
                  opened={mobileOpened}
                  onClick={toggleMobile}
                  hiddenFrom="sm"
                  size="sm"
                />
                <Burger
                  opened={desktopOpened}
                  onClick={toggleDesktop}
                  visibleFrom="md"
                  size="sm"
                />
                <Stack gap="0px" align="flex-start" justify="center" h="100%">
                  <Text
                    className={lobster.className}
                    size="xl"
                    fw={700}
                    style={{
                      background:
                        "linear-gradient(315deg, #b3e5fc 0%, #9fa8da 50%, #b39ddb 100%)",
                      WebkitBackgroundClip: "text",
                      WebkitTextFillColor: "transparent",
                      backgroundClip: "text",
                      color: "transparent",
                      display: "inline-block",
                      marginLeft: isMobile ? "60px" : "0",
                    }}
                  >
                    Dream-San
                  </Text>
                  <Text
                    size="sm"
                    hiddenFrom="sm"
                    style={{
                      marginLeft: "60px",
                      fontSize: "12px",
                      opacity: 0.7,
                    }}
                  >
                    Token Balance: {user?.token_balance || 0}
                  </Text>
                </Stack>
              </Group>
              <Group>
                <Box
                  hiddenFrom="sm"
                  style={{
                    position: "absolute",
                    right: "1rem",
                    top: "50%",
                    transform: "translateY(-50%)",
                  }}
                >
                  <Menu>
                    <Menu.Target>
                    <Avatar
                      color="violet"
                      radius="xl"
                      style={{
                        transition: "all 0.2s ease-in-out",
                        cursor: "pointer",
                        border: "2.5px solid rgba(255, 255, 255, 0.2)",
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "center"
                      }}
                    >
                      <Text 
                        size="25px" 
                        style={{ 
                          display: "flex", 
                          justifyContent: "center", 
                          alignItems: "center",
                          width: "100%",
                          height: "100%",
                          margin: 0
                        }}
                      >
                        {user?.email ? user.email[0].toUpperCase() : "U"}
                      </Text>
                    </Avatar>
                    </Menu.Target>
                    <Menu.Dropdown>
                      <Menu.Label>
                        <Text size="xl">
                          User: {user?.first_name || 'User'} {user?.last_name || ''}
                        </Text>
                      </Menu.Label>
                      <Menu.Label>
                        <Flex direction="row" align="center" gap="10px">
                          <Text size="xl">Subscribed: </Text>
                          <Text
                            size="xl"
                            span
                            c={user?.is_subscribed ? "green" : "red"}
                            fw={600}
                          >
                            {user?.is_subscribed ? "Yes" : "No"}
                          </Text>
                        </Flex>
                      </Menu.Label>
                      <Menu.Item
                        onClick={() => setIsSubscriptionModalOpen(true)}
                      >
                        <Text size="xl">Manage Subscription</Text>
                      </Menu.Item>
                      <Menu.Item>
                        <Stack align="center">
                          <Container
                            onClick={() => setIsTopUpModalOpen(true)}
                            style={{
                              backgroundColor: "rgba(179, 229, 252, 0.8)",
                              borderRadius: "8px",
                              padding: "10px 20px",
                              cursor: "pointer",
                              transition: "background-color 0.3s ease",
                              display: "flex",
                              justifyContent: "center",
                              alignItems: "center",
                              width: "100%",
                            }}
                            styles={(theme) => ({
                              root: {
                                "&:hover": {
                                  backgroundColor: theme.colors.blue[1],
                                },
                                "&:active": {
                                  backgroundColor: theme.colors.blue[2],
                                },
                              },
                            })}
                          >
                            <Text
                              size="25px"
                              fw={500}
                              span
                              style={{ color: "#2c2c2c" }}
                            >
                              Top Up
                            </Text>
                          </Container>
                        </Stack>
                      </Menu.Item>
                      <Menu.Item>
                        <Container
                          size="lg"
                          style={{
                            backgroundColor: "#7e57c2",
                            borderRadius: "8px",
                            padding: "10px 20px",
                            cursor: "pointer",
                            transition: "background-color 0.3s ease",
                            display: "flex",
                            justifyContent: "center",
                            alignItems: "center",
                            width: "100%",
                          }}
                        >
                          <LogoutLink
                          className="rounded-md px-4 py-2"
                          style={{
                            color: 'white',
                            textDecoration: 'none',
                            width: '100%',
                            textAlign: 'center',
                            display: 'block'
                          }}
                          postLogoutRedirectURL="/">Logout</LogoutLink>
                        </Container>
                      </Menu.Item>
                    </Menu.Dropdown>
                  </Menu>
                </Box>
                <Group visibleFrom="sm">
                  <Text size="xl" mr="md">
                    Token Balance: {user?.token_balance || 0}
                  </Text>
                  <Menu>
                    <Menu.Target>
                      <div
                        style={{
                          display: "inline-block",
                          borderRadius: "60%",
                          overflow: "hidden",
                        }}
                        onMouseEnter={(e) => {
                          const avatar = e.currentTarget
                            .firstElementChild as HTMLElement;
                          if (avatar) {
                            avatar.style.boxShadow = `
                      0 0 20px 10px rgba(255, 255, 255, 0.8),
                      0 0 40px 20px rgba(255, 255, 255, 0.6),
                      0 0 60px 30px rgba(255, 255, 255, 0.4),
                      0 0 80px 40px rgba(255, 255, 255, 0.2),
                      0 0 100px 50px rgba(255, 255, 255, 0.1)
                    `;
                            avatar.style.border =
                              "2px solid rgba(255, 255, 255, 1)";
                            avatar.style.fontWeight = "700";
                          }
                        }}
                        onMouseLeave={(e) => {
                          const avatar = e.currentTarget
                            .firstElementChild as HTMLElement;
                          if (avatar) {
                            avatar.style.boxShadow = "none";
                            avatar.style.border =
                              "2.5px solid rgba(255, 255, 255, 0.2)";
                            avatar.style.fontWeight = "400";
                          }
                        }}
                      >
                        <Avatar
                          color="white"
                          radius="xl"
                          style={{
                            transition: "all 0.2s ease-in-out",
                            cursor: "pointer",
                            display: "flex",
                            justifyContent: "center",
                            alignItems: "center"
                          }}
                        >
                          <Text 
                            size="25px"
                            style={{ 
                              display: "flex", 
                              justifyContent: "center", 
                              alignItems: "center",
                              width: "100%",
                              height: "100%",
                              margin: 0
                            }}
                          >
                            {user?.email ? user.email[0].toUpperCase() : "U"}
                          </Text>
                        </Avatar>
                      </div>
                    </Menu.Target>
                    <Menu.Dropdown>
                      <Menu.Label>
                        <Text size="xl">
                          User: {user?.first_name || 'User'} {user?.last_name || ''}
                        </Text>
                      </Menu.Label>
                      <Menu.Label>
                        <Flex direction="row" align="center" gap="10px">
                          <Text size="xl">Subscribed: </Text>
                          <Text
                            size="xl"
                            span
                            c={user?.is_subscribed ? "green" : "red"}
                            fw={600}
                          >
                            {user?.is_subscribed ? "Yes" : "No"}
                          </Text>
                        </Flex>
                      </Menu.Label>
                      <Menu.Item
                        onClick={() => setIsSubscriptionModalOpen(true)}
                      >
                        <Text size="xl">Manage Subscription</Text>
                      </Menu.Item>
                      <Menu.Item>
                        <Stack align="center">
                          <Container
                            onClick={() => setIsTopUpModalOpen(true)}
                            style={{
                              backgroundColor: "rgba(179, 229, 252, 0.8)",
                              borderRadius: "8px",
                              padding: "10px 20px",
                              cursor: "pointer",
                              transition: "background-color 0.3s ease",
                              display: "flex",
                              justifyContent: "center",
                              alignItems: "center",
                              width: "100%",
                            }}
                            styles={(theme) => ({
                              root: {
                                "&:hover": {
                                  backgroundColor: theme.colors.blue[1],
                                },
                                "&:active": {
                                  backgroundColor: theme.colors.blue[2],
                                },
                              },
                            })}
                          >
                            <Text
                              size="25px"
                              fw={500}
                              span
                              style={{ color: "#2c2c2c" }}
                            >
                              Top Up
                            </Text>
                          </Container>
                        </Stack>
                      </Menu.Item>
                      <Menu.Item>
                        <LogoutLink
                          className="rounded-md px-4 py-2"
                          style={{
                            backgroundColor: '#7e57c2',
                            color: 'white',
                            borderRadius: '8px',
                            padding: '8px 16px',
                            textDecoration: 'none',
                            width: '100%',
                            textAlign: 'center',
                            display: 'block'
                          }}
                          postLogoutRedirectURL="/"
                        >
                          Logout
                        </LogoutLink>
                      </Menu.Item>
                    </Menu.Dropdown>
                  </Menu>
                </Group>
              </Group>
            </Group>
          </Container>
        </AppShell.Header>

        <AppShell.Navbar
          p="md"
          style={{
            backgroundColor: "rgba(179, 229, 252, 0.8)",
            borderRight: "1px solid #9FA8DA",
            transition: "width 0.3s ease",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <Text size="xl" fw={700} mb={15} c="black">
            Dream History
          </Text>
          <Button
            onClick={() => {
              setActiveSessionId(null);
              setMessages([]);
            }}
            fullWidth
            mb={15}
          >
            Start New Dream Session
          </Button>
          <ScrollArea style={{ flex: 1 }} type="auto">
            <Stack gap="5px">
              {dreamHistory.map((dream) => (
                <Button
                  key={dream.id}
                  variant="subtle"
                  fullWidth
                  styles={{
                    root: {
                      justifyContent: "flex-start",
                      padding: "10px",
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                      height: "auto",
                      minHeight: 36,
                      transition: "background-color 0.2s ease",
                      "&:hover": {
                        backgroundColor: "rgba(255, 255, 255, 0.2)",
                      },
                    },
                    label: {
                      color: "black",
                      whiteSpace: "nowrap",
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      width: "100%",
                      textAlign: "left",
                    },
                  }}
                  onClick={() => {
                    loadDreamSession(dream.id);
                  }}
                >
                  <Stack gap="5px">
                    <Text size="xs" fw={700}>
                      {new Date(dream.created_at).toLocaleDateString()}
                    </Text>
                    <Text size="md">{truncateTitle(dream.dream_text)}</Text>
                  </Stack>
                </Button>
              ))}
            </Stack>
          </ScrollArea>
        </AppShell.Navbar>

        <AppShell.Main>
          <Container size="md" py="xl">
            <DisclaimerModal
              opened={isDisclaimerOpen}
              onClose={handleDisclaimerClose}
            />
            <Paper
              shadow="lg"
              radius="md"
              p="md"
              className="custom-scrollbar"
              style={{
                height: "max(80vh, calc(100vh - 160px))",
                display: "flex",
                flexDirection: "column",
                overflow: "visible",
                padding: "1rem",
                boxSizing: "border-box",
                backgroundColor: "rgba(255, 255, 255, 0.2)",
              }}
            >
              <ScrollArea
                type="always"
                offsetScrollbars
                classNames={classes}
                style={{
                  flex: 1,
                  marginBottom: "1rem",
                  backgroundColor: "transparent",
                }}
              >
                {isLoading ? (
                  <Group justify="center" mt="xl">
                    <Loader color="black" />
                  </Group>
                ) : (
                  messages.map((msg) => (
                    <Group
                      key={msg.id}
                      justify={
                        msg.user_id === currentUserId
                          ? "flex-end"
                          : "flex-start"
                      }
                      gap="xs"
                      mb="xs"
                    >
                      {msg.user_id !== currentUserId && msg.imageUrl && (
                        <Flex
                          justify="center"
                          align="center"
                          style={{ width: "100%", minHeight: 220, gap: "sm" }}
                        >
                          <Image
                            src={msg.imageUrl}
                            alt="Dream visualization"
                            radius="md"
                            width={200}
                            height={200}
                            fit="contain"
                          />
                        </Flex>
                      )}
                      <Paper
                        radius="md"
                        p="xs"
                        bg={
                          msg.user_id === currentUserId
                            ? "rgba(255, 255, 255, 0.5)"
                            : "rgba(179, 229, 252, 0.8)"
                        }
                      >
                        {msg.user_id === currentUserId ? (
                          <Text size="sm">{msg.content}</Text>
                        ) : (
                          <Markdown>{msg.content}</Markdown>
                        )}
                      </Paper>
                    </Group>
                  ))
                )}
                <div ref={scrollRef} />
              </ScrollArea>
              <Group
                align="flex-end"
                w="100%"
                style={{ flexDirection: isMobile ? "column" : "row" }}
              >
                <Textarea
                  placeholder="Type your message..."
                  value={newMessage}
                  onChange={(event) => setNewMessage(event.currentTarget.value)}
                  size="12px"
                  autosize
                  minRows={1}
                  maxRows={7}
                  style={{ width: isMobile ? "100%" : "85%" }}
                  disabled={sending}
                  styles={{
                    input: {
                      borderRadius: "10px",
                      padding: "0.75rem",
                      backgroundColor: "rgba(255, 255, 255, 0.5)",
                      border: "none",
                      height: "42.5px",
                      overflow: "hidden",
                      overflowY: "auto",
                      scrollbarWidth: "none",
                      msOverflowStyle: "none",
                    },
                  }}
                />
                <Button
                  loaderProps={{ size: 35 }}
                  color="#999999"
                  onClick={handleSendMessage}
                  loading={sending}
                  disabled={sending}
                  size="42px"
                  style={{
                    width: isMobile ? "100%" : "auto",
                    flex: isMobile ? "none" : 1.1,
                  }}
                >
                  {isMobile || isTablet ? (
                    <Text size="20px">☁️</Text>
                  ) : (
                    <Text size="20px">☁️ Send</Text>
                  )}
                </Button>
              </Group>
            </Paper>
          </Container>
        </AppShell.Main>

        <Modal
          opened={isSubscriptionModalOpen}
          onClose={() => setIsSubscriptionModalOpen(false)}
          title="Manage Subscription"
        >
          <Stack>
          <Button
            onClick={() => setContactModalOpened(true)}
            fullWidth
            mb="md"
            style={{
              backgroundColor: "rgba(179, 229, 252, 0.8)",
              borderRadius: "8px",
              padding: "10px 20px",
              cursor: "pointer",
              transition: "background-color 0.3s ease",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
            }}
            styles={(theme) => ({
              root: {
                "&:hover": {
                  backgroundColor: theme.colors.blue[1],
                },
                "&:active": {
                  backgroundColor: theme.colors.blue[2],
                },
              },
            })}
          >
            Contact Support
          </Button>

            {isSubscriptionActive ? (
              <Flex direction="row" align="center" gap="10px">
                <Text size="xl">Subscribed: </Text>
                <Text
                  size="xl"
                  span
                  c={user?.is_subscribed ? "green" : "red"}
                  fw={600}
                >
                  {user?.is_subscribed ? "Yes" : "No"}
                </Text>
              </Flex>
            ) : (
              <Card shadow="sm" padding="lg" radius="md" withBorder>
                <Card.Section>
                  <Image
                    component={NextImage}
                    src={dreamsanlogo}
                    height={310}
                    width={100}
                    alt="Cloud Heart"
                  />
                </Card.Section>
                <Stack>
                  <Text
                    size="xxl"
                    fw={1000}
                    ta="center"
                    c="black"
                    style={{ paddingTop: "25px" }}
                  >
                    🪙 1500 Tokens 🪙
                  </Text>
                  <Text
                    size="xxl"
                    fw={1000}
                    ta="center"
                    c="black"
                    style={{ paddingTop: "25px" }}
                  >
                    Unlock the mysteries of your subconscious with our exclusive
                    monthly subscription. Receive 30 personalized dream queries
                    each month to delve deeper into your dreams, uncover hidden
                    meanings, and gain profound insights into your inner world.
                    Don't miss the chance to transform your nightly visions into
                    a journey of self-discovery—subscribe today and elevate your
                    dream exploration!
                  </Text>
                </Stack>

                <Button
                  color="blue"
                  fullWidth
                  mt="md"
                  radius="md"
                  onClick={() =>
                    (window.location.href =
                      "https://buy.stripe.com/test_fZedTValBcA72uA9AA")
                  }
                >
                  Activate Subscription
                </Button>
              </Card>
            )}
            <Button
              color="red"
              fullWidth
              onClick={handleManageSubscription}
              styles={(theme) => ({
                root: {
                  "&:hover": {
                    backgroundColor: theme.colors.red[7],
                  },
                },
              })}
            >
              Cancel Subscription
            </Button>
          </Stack>
        </Modal>
        <ContactModal 
          opened={contactModalOpened}
          onClose={() => setContactModalOpened(false)}
        />
        <Modal
          opened={isTopUpModalOpen}
          onClose={() => {
            setIsTopUpModalOpen(false);
            setSelectedAmount(null);
          }}
          title="Top Up Tokens"
        >
          <AnimatePresence mode="wait">
            <motion.div
              key="topup-options"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              transition={{ duration: 0.5, ease: "easeInOut" }}
            >
              {isSubscriptionActive ? (
                <Card shadow="sm" padding="lg" radius="md" withBorder>
                  <Card.Section>
                    <Image
                      component={NextImage}
                      src={dreamsanlogo}
                      height={100}
                      width={100}
                      alt="Cloud Heart"
                    />
                  </Card.Section>
                  <Text
                    size="xxl"
                    fw={1000}
                    ta="center"
                    c="black"
                    style={{ paddingTop: "25px" }}
                  >
                    TOKENS
                  </Text>
                  <Stack mt="md">
                    <Button
                      onClick={() => {
                        setSelectedAmount(1500);
                        setConfirmationModalOpen(true);
                      }}
                      styles={(theme) => ({
                        root: {
                          backgroundColor: theme.colors.blue[6],
                          "&:hover": { backgroundColor: theme.colors.blue[7] },
                        },
                      })}
                    >
                      1500 Tokens
                    </Button>
                    <Button
                      onClick={() => {
                        setSelectedAmount(1000);
                        setConfirmationModalOpen(true);
                      }}
                      styles={(theme) => ({
                        root: {
                          backgroundColor: theme.colors.blue[6],
                          "&:hover": { backgroundColor: theme.colors.blue[7] },
                        },
                      })}
                    >
                      1000 Tokens
                    </Button>
                    <Button
                      onClick={() => {
                        setSelectedAmount(500);
                        setConfirmationModalOpen(true);
                      }}
                      styles={(theme) => ({
                        root: {
                          backgroundColor: theme.colors.blue[6],
                          "&:hover": { backgroundColor: theme.colors.blue[7] },
                        },
                      })}
                    >
                      500 Tokens
                    </Button>
                  </Stack>
                </Card>
              ) : (
                <Card shadow="sm" padding="lg" radius="md" withBorder>
                  <Text size="xl" fw={700} ta="center">
                    Subscribe to purchase tokens
                  </Text>
                </Card>
              )}
            </motion.div>
          </AnimatePresence>
        </Modal>

        <Modal
          opened={confirmationModalOpen}
          onClose={() => setConfirmationModalOpen(false)}
          title="Confirm Purchase"
        >
          <Text size="lg" mb="md">
            Are you sure you want to purchase {selectedAmount} tokens?
          </Text>
          <Group>
            <Button
              onClick={() => {
                let stripeUrl = "";

                // Check the selectedTokenAmount and assign the corresponding Stripe link
                if (selectedAmount === 500) {
                  stripeUrl = "https://buy.stripe.com/aEU29n2NPclfbYI6op";
                } else if (selectedAmount === 1000) {
                  stripeUrl = "https://buy.stripe.com/aEU7tH2NP9930g05km";
                } else if (selectedAmount === 1500) {
                  stripeUrl = "https://buy.stripe.com/dR601f3RT5WR8MwdQT";
                }

                if (stripeUrl) {
                  console.log(
                    `Processing payment for ${selectedAmount} tokens`
                  );
                  setConfirmationModalOpen(false);
                  setIsTopUpModalOpen(false);

                  // Redirect to the Stripe payment link
                  window.location.href = stripeUrl;
                } else {
                  console.error("Invalid token amount selected");
                }
              }}
              color="green"
            >
              Pay for Tokens
            </Button>

            <Button
              onClick={() => setConfirmationModalOpen(false)}
              color="gray"
            >
              No, Cancel
            </Button>
          </Group>
        </Modal>
      </AppShell>
    </MantineProvider>
  );
};

export default Chat;

================
File: components/chat/page.module.css
================
.scrollbar {

    &,
    &:hover {
      background-color: transparent;
    }

    padding-left: 5px;
    border-radius: 25px;
  
    &[data-orientation='vertical'] .thumb {
      background-color: rgba(179, 229, 252, 0.8);
    }
  }
  
  .corner {
    background-color: transparent;
    opacity: 0;
  }

================
File: components/contactModal/contactModal.tsx
================
'use client'

import React, { useState } from 'react';
import {
  Modal,
  TextInput,
  Textarea,
  Button,
  Group,
  Stack,
  Text,
  LoadingOverlay,
  Alert
} from '@mantine/core';
import { IconAlertCircle, IconCheck } from '@tabler/icons-react';

interface ContactModalProps {
  opened: boolean;
  onClose: () => void;
}

const ContactModal: React.FC<ContactModalProps> = ({ opened, onClose }) => {
  const [subject, setSubject] = useState('');
  const [message, setMessage] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [status, setStatus] = useState<'idle' | 'success' | 'error'>('idle');
  
  const resetForm = () => {
    setSubject('');
    setMessage('');
    setStatus('idle');
    setIsSubmitting(false);
  };

  const handleClose = () => {
    resetForm();
    onClose();
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setStatus('idle');

    try {
      const response = await fetch('/api/contact', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          subject,
          message,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to send message');
      }
      setStatus('success');
      
      // Close modal after success message
      setTimeout(() => {
        handleClose();
      }, 2000);

    } catch (error) {
      setStatus('error');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Modal
      opened={opened}
      onClose={handleClose}
      title={
        <Text size="xl" fw={700} c="#2c2c2c">
          Contact Us
        </Text>
      }
      styles={{
        content: {
          backgroundColor: 'rgba(255, 255, 255, 0.9)',
        },
        body: {
          padding: '20px',
        },
        header: {
          backgroundColor: 'rgba(179, 229, 252, 0.8)',
          borderBottom: '1px solid #9fa8da',
          marginBottom: '1rem',
        },
      }}
    >
      <form onSubmit={handleSubmit}>
        <Stack>
          <LoadingOverlay 
            visible={isSubmitting} 
            overlayProps={{ blur: 2 }}
            loaderProps={{ color: '#8da0cb' }}
          />
          
          {status === 'success' && (
            <Alert 
              color="teal" 
              title="Success!" 
              icon={<IconCheck size="1.1rem" />}
            >
              Your message has been sent successfully.
            </Alert>
          )}

          {status === 'error' && (
            <Alert 
              color="red" 
              title="Error" 
              icon={<IconAlertCircle size="1.1rem" />}
            >
              Failed to send message. Please try again.
            </Alert>
          )}

          <TextInput
            required
            label="Subject"
            value={subject}
            onChange={(e) => setSubject(e.target.value)}
            placeholder="Enter subject"
            styles={{
              input: {
                backgroundColor: 'rgba(179, 229, 252, 0.3)',
                border: '1px solid #9fa8da',
                '&:focus': {
                  borderColor: '#7986cb',
                },
              },
              label: {
                color: '#2c2c2c',
                marginBottom: '4px',
                fontWeight: 500,
              },
            }}
          />

          <Textarea
            required
            label="Message"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            placeholder="Type your message here"
            minRows={4}
            styles={{
              input: {
                backgroundColor: 'rgba(179, 229, 252, 0.3)',
                border: '1px solid #9fa8da',
                '&:focus': {
                  borderColor: '#7986cb',
                },
              },
              label: {
                color: '#2c2c2c',
                marginBottom: '4px',
                fontWeight: 500,
              },
            }}
          />

          <Group justify="flex-end" mt="md">
            <Button
              variant="light"
              onClick={handleClose}
              styles={{
                root: {
                  backgroundColor: 'rgba(179, 229, 252, 0.8)',
                  '&:hover': {
                    backgroundColor: 'rgba(179, 229, 252, 0.6)',
                  },
                },
              }}
            >
              Cancel
            </Button>
            <Button
              type="submit"
              loading={isSubmitting}
              styles={{
                root: {
                  backgroundColor: '#8da0cb',
                  '&:hover': {
                    backgroundColor: '#7a8bbd',
                  },
                },
              }}
            >
              Send Message
            </Button>
          </Group>
        </Stack>
      </form>
    </Modal>
  );
};

export default ContactModal;

================
File: components/disclaimer/disclaimermodal.module.css
================
/* DisclaimerModal.module.css */

/* Style for the modal title */
.title {
    color: #1976D2;
    font-weight: 700;
    font-size: 1.5rem;
  }
  
  /* Style for the modal body */
  .body {
    background-color: rgba(179, 229, 252, 0.9);
    padding: 20px;
    /* Removed border-radius to prevent conflicts */
  }
  
  /* Style for the content inside the modal */
  .content {
    color: #333;
  }
  
  /* Style for the accept button */
  .acceptButton {
    background-color: #2196F3;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.3s ease;
  }
  
  .acceptButton:hover {
    background-color: #1565C0;
  }

================
File: components/disclaimer/dislaimer.tsx
================
import React from 'react';
import { Modal, Text, Stack, Button, ScrollArea, Group, Loader, Flex, Image, Paper } from '@mantine/core';
import styles from './disclaimermodal.module.css';

interface DisclaimerModalProps {
  opened: boolean;
  onClose: () => void;
}

const DisclaimerModal: React.FC<DisclaimerModalProps> = ({ opened, onClose }) => {
  return (
    <Modal 
      opened={opened} 
      onClose={onClose} 
      title="Dream-San App Disclaimer" 
      size="lg"
      withCloseButton={false}
      closeOnClickOutside={false}
      closeOnEscape={false}
      radius="16px" // Applies a 16px border-radius to the entire modal
      styles={{
        header: {
          backgroundColor: 'rgba(179, 229, 252, 1)', // Opaque background
          padding: '16px 24px', // Optional: Adjust padding as needed
        },
        body: {
          backgroundColor: 'rgba(179, 229, 252, 0.9)', // Semi-transparent body background
          padding: '20px',
        },
      }}
    >
      <div className={styles.content}>
        <ScrollArea
          style={{ height: '400px', marginBottom: '1rem' }} // Adjust height as needed
          styles={(theme) => ({
            root: {
              background: 'transparent', // Transparent outer container
            },
            viewport: {
              background: 'transparent', // Transparent scrollable area
            },
            scrollbar: {
              background: 'transparent', // Transparent scrollbar track
            },
            thumb: {
              backgroundColor: theme.colors.gray[3], // Scrollbar thumb color
              '&:hover': {
                backgroundColor: theme.colors.gray[4], // Darker on hover
              },
            },
            corner: {
              background: 'transparent', // Transparent corner
            },
          })}
        >
          <Stack gap="md">
            <Text>
              Welcome to Dream-San, your AI-powered dream interpretation companion. Before you begin your journey of dream exploration, please read and acknowledge the following disclaimer:
            </Text>
            
            <Text fw={700}>1. Purpose and Limitations:</Text>
            <Text>
              Dream-San is designed for entertainment and self-reflection purposes only. The interpretations provided are generated by artificial intelligence and should not be considered as professional psychological or therapeutic advice.
            </Text>

            <Text fw={700}>2. No Substitute for Professional Help:</Text>
            <Text>
              Our app is not a substitute for professional medical, psychological, or psychiatric treatment. If you are experiencing mental health concerns or recurring distressing dreams, please consult with a qualified healthcare professional.
            </Text>

            <Text fw={700}>3. AI Interpretation:</Text>
            <Text>
              The dream interpretations are generated by AI based on patterns and information it has been trained on. These interpretations may not always be accurate or applicable to your personal situation.
            </Text>

            <Text fw={700}>4. Privacy and Data Use:</Text>
            <Text>
              While we take measures to protect your privacy, please be aware that the dreams you share are processed by our AI system. Do not share sensitive personal information in your dream descriptions.
            </Text>

            <Text fw={700}>5. User Responsibility:</Text>
            <Text>
              Users are responsible for their own actions and decisions based on the app's interpretations. Dream-San and its creators are not liable for any consequences resulting from the use of this app.
            </Text>

            <Text fw={700}>6. Accuracy and Completeness:</Text>
            <Text>
              We strive to provide helpful and insightful interpretations, but we do not guarantee the accuracy, completeness, or usefulness of any interpretation provided by the app.
            </Text>

            <Text fs='italic'>
              By using Dream-San, you acknowledge that you have read, understood, and agree to this disclaimer. If you do not agree with these terms, please do not use the app.
            </Text>
          </Stack>
        </ScrollArea>
        <Button onClick={onClose} fullWidth className={styles.acceptButton}>
          I Understand and Accept
        </Button>
      </div>
    </Modal>
  );
};

export default DisclaimerModal;

================
File: components/StatsCard/StatsCard.tsx
================
import React from 'react';
import { Card, Text, Group, Stack } from '@mantine/core';

interface StatsCardProps {
  title: string;
  stat: string | number;
}

const StatsCard: React.FC<StatsCardProps> = ({ title, stat }) => {
  return (
    <Card shadow="sm" padding="lg" radius="md" withBorder>
      <Group>
        <Stack>
            <Text>{title}</Text>
            <Text size="xl">{stat}</Text>
        </Stack>
      </Group>
    </Card>
  );
};

export default StatsCard;

================
File: components/token system/TokenSystem.ts
================
// tokenSystem.ts
import { supabase } from '../../supabase/supabaseClient';
import { estimateTokenCost } from '../utils/tokenUtils/TokenUtility';

export async function processTokenTransaction(userId: string, query: string): Promise<boolean> {
  const tokenCost = estimateTokenCost(query);

  // Start a Supabase transaction
  const { data, error } = await supabase.rpc('process_token_transaction', {
    p_user_id: userId,
    p_token_cost: tokenCost
  });

  if (error) {
    console.error('Error processing token transaction:', error);
    throw new Error(`Token transaction failed: ${error.message}`);
  }

  return data === true;
}

================
File: components/utils/tokenUtils/TokenUtility.ts
================
// tokenUtils.ts
import { TOKENS_PER_CHARACTER, MIN_TOKENS_PER_QUERY } from '../../../constants/constants';
import { User } from './types'; 

export function estimateTokenCost(query: string): number {
  const estimatedTokens = Math.ceil(query.length * TOKENS_PER_CHARACTER);
  return Math.max(estimatedTokens, MIN_TOKENS_PER_QUERY);
}

export function hasEnoughTokens(user: User, query: string): boolean {
  const estimatedCost = estimateTokenCost(query);
  return user.token_balance >= estimatedCost;  
}

================
File: components/utils/tokenUtils/types.ts
================
// types.ts
export interface User {
    id: string;
    token_balance: number;  
  }
  
  export interface TokenTransaction {
    userId: string;
    amount: number;
    timestamp: Date;
  }

================
File: components/utils/user-utils.ts
================
'use client'

import { supabase } from '@/supabase/supabaseClient'

type KindeUser = {
  id: string
  email: string | null
  given_name: string | null
  family_name: string | null
  picture?: string | null
}

/**
 * Checks if a user exists in Supabase database and creates one if they don't
 */
export async function syncUserWithDatabase(kindeUser: KindeUser) {
  try {
    if (!kindeUser?.email) {
      console.error('Kinde user email is missing')
      return null
    }

    // Check for existing user by email
    const { data: existingUserByEmail, error: emailSearchError } = await supabase
      .from('users')
      .select('*')
      .eq('email', kindeUser.email.toLowerCase())
      .single()

    if (emailSearchError && emailSearchError.code !== 'PGRST116') {
      console.error('Error checking for existing user by email:', emailSearchError)
    }

    // If found user by email, update their Kinde ID if needed
    if (existingUserByEmail) {
      if (!existingUserByEmail.kinde_user_id || existingUserByEmail.kinde_user_id !== kindeUser.id) {
        const { error: updateError } = await supabase
          .from('users')
          .update({ 
            kinde_user_id: kindeUser.id,
            first_name: kindeUser.given_name || existingUserByEmail.first_name,
            last_name: kindeUser.family_name || existingUserByEmail.last_name,
            avatar_url: kindeUser.picture || existingUserByEmail.avatar_url
          })
          .eq('id', existingUserByEmail.id)

        if (updateError) {
          console.error('Error updating user with Kinde ID:', updateError)
        }
      }
      return existingUserByEmail
    }

    // Check for existing user by Kinde ID
    const { data: existingUserById, error: idSearchError } = await supabase
      .from('users')
      .select('*')
      .eq('kinde_user_id', kindeUser.id)
      .single()

    if (idSearchError && idSearchError.code !== 'PGRST116') {
      console.error('Error checking for existing user by Kinde ID:', idSearchError)
    }

    // If found user by Kinde ID, update their email if needed
    if (existingUserById) {
      if (existingUserById.email !== kindeUser.email) {
        const { error: updateError } = await supabase
          .from('users')
          .update({ 
            email: kindeUser.email.toLowerCase(),
            first_name: kindeUser.given_name || existingUserById.first_name,
            last_name: kindeUser.family_name || existingUserById.last_name,
            avatar_url: kindeUser.picture || existingUserById.avatar_url
          })
          .eq('id', existingUserById.id)

        if (updateError) {
          console.error('Error updating user email:', updateError)
        }
      }
      return existingUserById
    }

    // Create new user if none exists
    const newUser = {
      kinde_user_id: kindeUser.id,
      email: kindeUser.email.toLowerCase(),
      first_name: kindeUser.given_name || '',
      last_name: kindeUser.family_name || '',
      avatar_url: kindeUser.picture || '',
      token_balance: 250, // Default token balance
      tokens_spent: 0,
      is_subscribed: false
    }

    const { data: insertedUser, error: insertError } = await supabase
      .from('users')
      .insert(newUser)
      .select('*')
      .single()

    if (insertError) {
      console.error('Error creating new user:', insertError)
      return null
    }

    return insertedUser
  } catch (err) {
    console.error('Exception in syncUserWithDatabase:', err)
    return null
  }
}

/**
 * Fetches the current user data from Supabase based on Kinde user information
 */
export async function getCurrentUserData(kindeUser: KindeUser | null) {
  if (!kindeUser || !kindeUser.email) {
    return null
  }
  
  try {
    // Try to find user by Kinde ID
    const { data: userByKindeId, error: kindeIdError } = await supabase
      .from('users')
      .select('*')
      .eq('kinde_user_id', kindeUser.id)
      .single()
    
    if (!kindeIdError && userByKindeId) {
      return userByKindeId
    }
    
    // If not found by Kinde ID, try by email
    const { data: userByEmail, error: emailError } = await supabase
      .from('users')
      .select('*')
      .eq('email', kindeUser.email.toLowerCase())
      .single()
    
    if (!emailError && userByEmail) {
      // Update the Kinde ID if it's missing
      if (!userByEmail.kinde_user_id) {
        await supabase
          .from('users')
          .update({ kinde_user_id: kindeUser.id })
          .eq('id', userByEmail.id)
      }
      return userByEmail
    }
    
    // If user doesn't exist at all, create a new one
    return await syncUserWithDatabase(kindeUser)
  } catch (error) {
    console.error('Error fetching current user data:', error)
    return null
  }
}

================
File: components/dreamhistorymenu.tsx
================
import React, { useState } from 'react';
import { Paper, Text, ScrollArea, Button, useMantineTheme, Box, Drawer } from '@mantine/core';
import { IconMenu2 } from '@tabler/icons-react';
import { useMediaQuery } from '@mantine/hooks';

interface DreamHistoryItem {
  id: string;
  title: string;
  timestamp: string;
}

const DreamHistoryMenu: React.FC = () => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const theme = useMantineTheme();
  const isMobile = useMediaQuery('(max-width: 768px)');

  const dreamHistory: DreamHistoryItem[] = [
    { id: '1', title: 'Flying over mountains', timestamp: '2023-06-01' },
    { id: '2', title: 'Underwater city with mermaids and talking fish', timestamp: '2023-06-03' },
  ];

  const truncateTitle = (title: string) => {
    const words = title.split(' ');
    if (words.length > 4) {
      return words.slice(0, 4).join(' ') + '...';
    }
    return title;
  };

  const MenuContent = () => (
    <Box p="md">
      <Text size="xl" fw={700} style={{ marginBottom: '15px', color: 'black' }}>
        Dream History
      </Text>
      <ScrollArea style={{ height: isMobile ? 'calc(100vh - 120px)' : 'calc(100% - 60px)' }} type='never'>
        {dreamHistory.map((dream) => (
          <Button
            key={dream.id}
            variant="subtle"
            fullWidth
            styles={(theme) => ({
              root: {
                justifyContent: 'flex-start',
                padding: '10px',
                marginBottom: '10px',
                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                height: 'auto',
                minHeight: 36,
                transition: 'background-color 0.2s ease',
                '&:hover': {
                  backgroundColor: 'rgba(255, 255, 255, 0.2)',
                },
              },
              label: {
                color: 'black',
                whiteSpace: 'nowrap',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                width: '100%',
                textAlign: 'left',
              },
            })}
            onClick={() => {}}
          >
            {truncateTitle(dream.title)}
          </Button>
        ))}
      </ScrollArea>
    </Box>
  );

  if (isMobile) {
    return (
      <>
        <Button
          variant="subtle"
          onClick={() => setIsOpen(true)}
          style={{
            position: 'absolute',
            top: 10,
            left: 5,
          }}
        >
        <IconMenu2 size={24}  />
        </Button>
        <Drawer
          opened={isOpen}
          onClose={() => setIsOpen(false)}
          title="Dream History"
          padding="md"
          size="100%"
          position="left"
        >
          <MenuContent />
        </Drawer>
      </>
    );
  }

  return (
    <Paper
      style={{
        position: 'fixed',
        left: 0,
        top: 60,
        bottom: 0,
        width: isExpanded ? '250px' : '40px',
        transition: 'width 0.3s ease',
        backgroundColor: 'rgba(179, 229, 252, 0.8)',
        borderRight: '1px solid #9fa8da',
        overflow: 'hidden',
        zIndex: 1000,
        display: 'flex',
        flexDirection: 'column',
      }}
      onMouseEnter={() => setIsExpanded(true)}
      onMouseLeave={() => setIsExpanded(false)}
    >
      {isExpanded ? (
        <MenuContent />
      ) : (
        <Button
          variant="subtle"
          style={{
            padding: '10px',
            backgroundColor: 'transparent',
            marginTop: 'auto',
          }}
        >
          <IconMenu2 size={24} />
        </Button>
      )}
    </Paper>
  );
};

export default DreamHistoryMenu;

================
File: constants/constants.ts
================
// constants.ts
export const TOKENS_PER_CHARACTER = 0.2;
export const MIN_TOKENS_PER_QUERY = 10;

================
File: supabase/supabaseClient.js
================
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_KEY || process.env.SUPABASE_KEY

if (!supabaseUrl || !supabaseKey) {
  throw new Error('Missing Supabase environment variables')
}

export const supabase = createClient(supabaseUrl, supabaseKey, {
  auth: {
    flowType: 'pkce',
    persistSession: true,
    autoRefreshToken: true
  }
})

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: middelware.ts
================
export const config = {
  matcher: ["/chat", "/api/chat"],
}

================
File: middleware.ts
================
import { NextRequest } from 'next/server'
import { getKindeServerSession } from '@kinde-oss/kinde-auth-nextjs/server'

// This function can be marked `async` if using `await` inside
export async function middleware(request: NextRequest) {
  const { isAuthenticated } = getKindeServerSession()
  
  // If the user is not authenticated and trying to access protected routes
  if (!(await isAuthenticated())) {
    return Response.redirect(new URL('/', request.url))
  }
}

// See "Matching Paths" below to learn more
export const config = {
  matcher: [
    '/chat/:path*',
    '/admin/:path*',
    '/api/dreamy/:path*',
    '/api/dalle/:path*',
    '/api/process-query/:path*'
  ],
}

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */
const nextConfig = {
    env: {
        SUPABASE_URL: process.env.SUPABASE_URL,
        SUPABASE_KEY: process.env.SUPABASE_KEY,
        OPENAI_API_KEY: process.env.OPENAI_API_KEY,
        STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
        STRIPE_PUBLISHABLE_KEY: process.env.STRIPE_PUBLISHABLE_KEY,
        STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
        API_URL: process.env.API_URL,
        CRON_SECRET: process.env.CRON_SECRET
      },
};

export default nextConfig;

================
File: package.json
================
{
  "name": "dream-net",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@kinde-oss/kinde-auth-nextjs": "^2.5.3",
    "@mantine/carousel": "^7.12.2",
    "@mantine/core": "^7.12.2",
    "@mantine/dates": "^7.12.2",
    "@mantine/dropzone": "^7.12.2",
    "@mantine/form": "^7.12.2",
    "@mantine/hooks": "^7.12.2",
    "@mantine/modals": "^7.12.2",
    "@mantine/notifications": "^7.12.2",
    "@stripe/stripe-js": "^4.7.0",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "^0.5.1",
    "@supabase/supabase-js": "^2.45.4",
    "@tabler/icons-react": "^3.19.0",
    "dayjs": "^1.11.13",
    "dotenv": "^16.4.5",
    "embla-carousel-react": "^8.3.0",
    "framer-motion": "^11.11.0",
    "micro": "^10.0.1",
    "next": "14.2.13",
    "nodemailer": "^6.9.15",
    "openai": "^4.87.3",
    "react": "^18",
    "react-dom": "^18",
    "react-markdown": "^8.0.7",
    "react-simple-typewriter": "^5.0.1",
    "stripe": "^17.1.0"
  },
  "devDependencies": {
    "@types/micro": "^10.0.0",
    "@types/node": "^20",
    "@types/nodemailer": "^6.4.16",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "postcss": "^8.4.47",
    "postcss-preset-mantine": "^1.17.0",
    "postcss-simple-vars": "^7.0.1",
    "typescript": "^5"
  }
}

================
File: postcss.config.cjs
================
module.exports = {
    plugins: {
      'postcss-preset-mantine': {},
      'postcss-simple-vars': {
        variables: {
          'mantine-breakpoint-xs': '36em',
          'mantine-breakpoint-sm': '48em',
          'mantine-breakpoint-md': '62em',
          'mantine-breakpoint-lg': '75em',
          'mantine-breakpoint-xl': '88em',
        },
      },
    },
  };

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", "app/api/auth/[...nextauth].ts"],
  "exclude": ["node_modules"]
}

================
File: vercel.json
================
{
  "crons": [{
    "path": "/api/cron/monthly-token-distribution",
    "schedule": "0 1 1 * *"
  }],
  "functions": {
    "app/api/**/*.ts": {
      "maxDuration": 300
    }
  }
}
